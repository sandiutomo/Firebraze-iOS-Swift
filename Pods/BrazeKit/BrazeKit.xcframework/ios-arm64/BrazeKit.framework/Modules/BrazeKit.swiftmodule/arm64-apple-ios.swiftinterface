// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.9.10 clang-1600.0.26.2)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -enable-bare-slash-regex -module-name BrazeKit
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import ActivityKit
import CommonCrypto
import CoreTelephony
import Dispatch
import Foundation
import MachO
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension BrazeKit.Braze.Banner {
  @available(swift, obsoleted: 0.0.1)
  @objc(properties) final public var _objc_properties: [Swift.String : Any] {
    @objc get
  }
  @objc(numberPropertyForKey:) final public func _objc_numberProperty(key: Swift.String) -> Foundation.NSNumber?
  @objc(timestampPropertyForKey:) final public func _objc_timestampProperty(key: Swift.String) -> Foundation.NSNumber?
  @objc(boolPropertyForKey:) final public func _objc_boolProperty(key: Swift.String) -> Foundation.NSNumber?
  @objc(jsonPropertyForKey:) final public func _objc_jsonProperty(key: Swift.String) -> Foundation.NSDictionary?
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZBanner) final public class Banner : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    @objc final public var trackingId: Swift.String {
      @objc get
    }
    @objc final public var placementId: Swift.String {
      @objc get
    }
    @objc final public var html: Swift.String {
      @objc get
    }
    @objc final public var expiresAt: Swift.Int {
      @objc get
    }
    @objc final public var isTestSend: Swift.Bool {
      @objc get
    }
    @objc final public var isControl: Swift.Bool {
      @objc get
    }
    final public var properties: [Swift.String : Any] {
      get
    }
    @objc final public var context: BrazeKit.Braze.Banner.Context? {
      @objc get
    }
    @objc(stringPropertyForKey:) final public func stringProperty(key: Swift.String) -> Swift.String?
    final public func numberProperty(key: Swift.String) -> Swift.Double?
    final public func timestampProperty(key: Swift.String) -> Swift.Int?
    final public func boolProperty(key: Swift.String) -> Swift.Bool?
    @objc(imagePropertyForKey:) final public func imageProperty(key: Swift.String) -> Swift.String?
    final public func jsonProperty(key: Swift.String) -> [Swift.String : Any]?
    final public func jsonProperty<T>(key: Swift.String, type: T.Type, decoder: Foundation.JSONDecoder = JSONDecoder()) -> T? where T : Swift.Decodable
    @objc override dynamic public init()
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    @objc final public func json() -> Foundation.Data?
    @objc public static func decoding(json: Foundation.Data) -> Self?
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
  }
}
extension BrazeKit.Braze.Banner {
  @objc(BRZBannerContext) final public class Context : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping (Swift.String?) -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.Banner.ClickAction, Any?) -> Swift.Void)
    @objc convenience public init(banner: BrazeKit.Braze.Banner, using braze: BrazeKit.Braze)
    @objc final public func logImpression()
    @objc final public func logClick(buttonId: Swift.String?)
    @objc final public func logError(_ error: any Swift.Error)
    final public func processClickAction(_ clickAction: BrazeKit.Braze.Banner.ClickAction, target: Any?)
    @objc deinit
  }
}
extension BrazeKit.Braze.Banner {
  @objc final public func logImpression(using braze: BrazeKit.Braze)
  @objc final public func logClick(buttonId: Swift.String?, using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.Banner {
  public enum ClickAction : Swift.Hashable, Swift.Codable {
    case none
    case url(Foundation.URL, useWebView: Swift.Bool)
    public var url: Foundation.URL? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.Banner.ClickAction, b: BrazeKit.Braze.Banner.ClickAction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.Banners {
  @available(swift, obsoleted: 0.0.1)
  @objc(requestBannersRefreshForPlacementIds:completion:) final public func _objc_requestBannersRefresh(for placementIds: [Swift.String], _ completion: @escaping (([Swift.String : BrazeKit.Braze.Banner]?, (any Swift.Error)?) -> Swift.Void))
  @available(swift, obsoleted: 0.0.1)
  @objc(requestBannersRefreshForPlacementIds:) final public func _objc_requestBannersRefresh(for placementIds: [Swift.String])
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZBanners) final public class Banners : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public var bannersStream: _Concurrency.AsyncStream<[Swift.String : BrazeKit.Braze.Banner]> {
      get
    }
    @objc(getBannerFor:completion:) final public func getBanner(for placementId: Swift.String, _ completion: @escaping @_Concurrency.MainActor (BrazeKit.Braze.Banner?) -> Swift.Void)
    final public func requestBannersRefresh(placementIds: [Swift.String], _ completion: (@_Concurrency.MainActor (Swift.Result<[Swift.String : BrazeKit.Braze.Banner], any Swift.Error>) -> Swift.Void)? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    @discardableResult
    final public func requestBannersRefresh(placementIds: [Swift.String], fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line) async throws -> [Swift.String : BrazeKit.Braze.Banner]
    @objc final public func subscribeToUpdates(_ update: @escaping @_Concurrency.MainActor ([Swift.String : BrazeKit.Braze.Banner]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc final public func registerView(_ placement: any BrazeKit.BrazeBannerPlacement)
    @objc deinit
  }
}
extension BrazeKit.Braze {
  @available(swift, obsoleted: 0.0.1)
  @objc final public func _requestEnableSDKOnNextAppRun()
  @available(swift, obsoleted: 0.0.1)
  @objc public static func _localize(_ key: Swift.String) -> Swift.String
  @available(swift, obsoleted: 0.0.1)
  @objc final public func _contentCardsApplyLocalCards()
}
extension BrazeKit.Braze {
  @available(swift, obsoleted: 0.0.1)
  @objc(delegate) weak final public var _objc_delegate: (any BrazeKit._OBJC_BrazeDelegate)? {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(inAppMessagePresenter) final public var _objc_inAppMessagePresenter: (any BrazeKit._OBJC_BrazeInAppMessagePresenter)? {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(updateTrackingAllowListAdding:removing:) final public func _objc_updateTrackingAllowList(adding: Swift.Set<BrazeKit._OBJC_BRZTrackingProperty>? = nil, removing: Swift.Set<BrazeKit._OBJC_BRZTrackingProperty>? = nil)
}
@_inheritsConvenienceInitializers @objc final public class Braze : ObjectiveC.NSObject, @unchecked Swift.Sendable {
  @objc(sdkVersion) public static let version: Swift.String
  @objc final public var enabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public let configuration: BrazeKit.Braze.Configuration
  @objc final public let user: BrazeKit.Braze.User
  @objc final public let notifications: BrazeKit.Braze.Notifications
  @objc final public let contentCards: BrazeKit.Braze.ContentCards
  @objc final public let featureFlags: BrazeKit.Braze.FeatureFlags
  @objc final public let banners: BrazeKit.Braze.Banners
  final public let liveActivities: BrazeKit.Braze.LiveActivities
  final public var inAppMessagePresenter: (any BrazeKit.BrazeInAppMessagePresenter)? {
    get
    set
  }
  weak final public var delegate: (any BrazeKit.BrazeDelegate)? {
    get
    set
  }
  @objc weak final public var sdkAuthDelegate: (any BrazeKit.BrazeSDKAuthDelegate)? {
    @objc get
    @objc set
  }
  @objc final public var deviceId: Swift.String {
    @objc get
  }
  @available(*, unavailable)
  @objc override dynamic public init()
  @objc public init(configuration: BrazeKit.Braze.Configuration)
  @objc deinit
}
@objc public enum _COMPAT_ABKRequestProcessingPolicy : Swift.Int {
  case manualRequestProcessing = 0
  case automaticRequestProcessing = 1
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum _COMPAT_ABKSDKFlavor : Swift.Int {
  case VANILLA
  case UNITY = 1
  case REACT
  case CORDOVA
  case XAMARIN
  case FLUTTER
  case SEGMENT
  case MPARTICLE
  case TEALIUM
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum _COMPAT_ABKSdkMetadata : Swift.String {
  case adjust
  case airBridge
  case appsFlyer
  case bluedot
  case branch
  case cordova
  case carthage
  case cocoaPods
  case cordovaPM
  case expo
  case foursquare
  case flutter
  case googleTagManager
  case gimbal
  case gradle
  case ionic
  case kochava
  case manual
  case mparticle
  case mParticle
  case nativeScript
  case NPM
  case nuGet
  case pub
  case radar
  case reactNative
  case reactNativeNewArch
  case segment
  case singular
  case swiftPM
  case tealium
  case unreal
  case unityPM
  case unity
  case vizbee
  case xamarin
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension BrazeKit.Braze {
  @available(*, deprecated, message: "BrazeKit does not provide a singleton instance. You are now expected to keep a reference of the Braze instance yourself after initialization.")
  @objc final public class func sharedInstance() -> BrazeKit.Braze?
  @available(*, deprecated, message: "BrazeKit does not provide a singleton instance. You are now expected to keep a reference of the Braze instance yourself after initialization.")
  @objc final public class func unsafeInstance() -> BrazeKit.Braze
  @available(*, deprecated, message: "Migrating the SDK initialization to the 'Braze(configuration:)' initializer disables most compatibility features. This step should be performed last in your migration process.\n\nAfter updating the SDK initialization and configuration, the SDK:\n- Will not read the `Info.plist` based SDK configuration.\n- Will not be compatible with `BrazeKitCompat` (`AppboyKit`) symbols.\n- Will not be compatible with `BrazeUICompat` (`AppboyUI`) UI components.\n- Will not emit the Content Cards updates via the Notification Center.\n- Will not automatically use the `BrazeLocation` library.\n- Will not read the [`identifierForVendor`](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor) as part of the ``Braze/Configuration-swift.class/devicePropertyAllowList`` configuration.\n- Will not depend on [`SDWebImage`](https://github.com/SDWebImage/SDWebImage).\n- Will not support GIFs out of the box.\n\nSee our migration guide for instructions to properly migrate each feature: https://braze-inc.github.io/braze-swift-sdk/documentation/braze/appboy-migration-guide")
  @objc(startWithApiKey:inApplication:withLaunchOptions:) final public class func start(withApiKey apiKey: Swift.String, in application: UIKit.UIApplication, withLaunchOptions launchOptions: [Swift.AnyHashable : Any]? = nil)
  @available(*, deprecated, message: "Migrating the SDK initialization to the 'Braze(configuration:)' initializer disables most compatibility features. This step should be performed last in your migration process.\n\nAfter updating the SDK initialization and configuration, the SDK:\n- Will not read the `Info.plist` based SDK configuration.\n- Will not be compatible with `BrazeKitCompat` (`AppboyKit`) symbols.\n- Will not be compatible with `BrazeUICompat` (`AppboyUI`) UI components.\n- Will not emit the Content Cards updates via the Notification Center.\n- Will not automatically use the `BrazeLocation` library.\n- Will not read the [`identifierForVendor`](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor) as part of the ``Braze/Configuration-swift.class/devicePropertyAllowList`` configuration.\n- Will not depend on [`SDWebImage`](https://github.com/SDWebImage/SDWebImage).\n- Will not support GIFs out of the box.\n\nSee our migration guide for instructions to properly migrate each feature: https://braze-inc.github.io/braze-swift-sdk/documentation/braze/appboy-migration-guide")
  @objc(startWithApiKey:inApplication:withLaunchOptions:withAppboyOptions:) final public class func start(withApiKey apiKey: Swift.String, in application: UIKit.UIApplication, withLaunchOptions launchOptions: [Swift.AnyHashable : Any]? = nil, withAppboyOptions appboyOptions: [Swift.AnyHashable : Any]? = nil)
  @available(*, deprecated, renamed: "contentCards")
  @objc final public var contentCardsController: Swift.AnyObject {
    @objc get
  }
  @available(*, deprecated, message: "request processing policy must be set using the 'Braze.Configuration' object at SDK initialization")
  @objc final public var requestProcessingPolicy: BrazeKit._COMPAT_ABKRequestProcessingPolicy {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "use 'set(identifierForAdvertiser:)' and 'set(adTrackingEnabled:)' instead")
  @objc final public var idfaDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, renamed: "delegate")
  @objc final public var sdkAuthenticationDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, renamed: "inAppMessagePresenter")
  @objc final public var inAppMessageController: Swift.AnyObject {
    @objc get
  }
  @available(*, deprecated, message: "use 'configuration.location' to access location analytics settings")
  @objc final public var locationManager: Swift.AnyObject {
    @objc get
  }
  @available(*, deprecated, renamed: "delegate")
  @objc weak final public var appboyUrlDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "imageDelegate is not needed anymore")
  @objc final public var imageDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "SDK flavor must be set using the 'Braze.Configuration' object at SDK initialization")
  @objc final public var sdkFlavor: BrazeKit._COMPAT_ABKSDKFlavor {
    @objc get
    @objc set
  }
  @available(*, deprecated, renamed: "requestImmediateDataFlush()")
  @objc final public func flushDataAndProcessRequestQueue()
  @available(*, unavailable, message: "use the 'enabled' boolean property to disable / enable the SDK")
  @objc final public func shutdownServerCommunication()
  @available(*, deprecated, renamed: "changeUser(userId:)")
  final public func changeUser(_ userId: Swift.String)
  @available(*, deprecated, renamed: "changeUser(userId:sdkAuthSignature:)")
  final public func changeUser(_ userId: Swift.String, sdkAuthSignature: Swift.String?)
  @available(*, deprecated, renamed: "set(sdkAuthenticationSignature:)")
  @objc final public func setSdkAuthenticationSignature(_ signature: Swift.String)
  @available(*, deprecated, message: "unsubscribing from SDK authentication errors is not needed anymore")
  @objc final public func unsubscribeFromSdkAuthenticationErrors()
  @available(*, deprecated, renamed: "logCustomEvent(name:)")
  final public func logCustomEvent(_ eventName: Swift.String)
  @available(*, deprecated, renamed: "logCustomEvent(name:properties:)")
  @objc final public func logCustomEvent(_ eventName: Swift.String, withProperties properties: [Swift.AnyHashable : Any]?)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:properties:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber, withProperties properties: [Swift.AnyHashable : Any]?)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:quantity:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber, withQuantity quantity: Swift.UInt)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:quantity:properties:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber, withQuantity quantity: Swift.UInt, andProperties properties: [Swift.AnyHashable : Any]?)
  @available(*, deprecated, message: "logging the content cards displayed event is not needed anymore")
  @objc final public func logContentCardsDisplayed()
  @available(*, deprecated, message: "renamed to 'contentCards.requestRefresh(_:)'")
  @objc final public func requestContentCardsRefresh()
  @available(*, deprecated, message: "renamed to 'requestGeofences(latitude:longitude:)'. ⚠️ Important: the order of the parameters have been changed")
  @objc final public func requestGeofences(withLongitude longitude: Swift.Double, latitude: Swift.Double)
  @available(*, deprecated, renamed: "deviceId")
  @objc final public func getDeviceId() -> Swift.String
  @available(*, deprecated, message: "renamed to 'notifications.register(deviceToken:)'")
  @objc final public func registerDeviceToken(_ deviceToken: Foundation.Data)
  @available(*, unavailable, message: "BrazeKit / BrazeKitCompat doesn't provide support for this deprecated method. Push notifications support must be integrated using the 'UserNotifications' framework. See our push integration documentation for more details.")
  @objc(registerApplication:didReceiveRemoteNotification:) final public func register(_ application: UIKit.UIApplication, didReceiveRemoteNotification notification: [Swift.AnyHashable : Any])
  @available(*, deprecated, message: "renamed to 'notifications.handleBackgroundNotification(userInfo:fetchCompletionHandler:)'")
  @objc(registerApplication:didReceiveRemoteNotification:fetchCompletionHandler:) final public func register(_ application: UIKit.UIApplication, didReceiveRemoteNotification notification: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: ((UIKit.UIBackgroundFetchResult) -> Swift.Void)? = nil)
  @available(*, unavailable, message: "BrazeKit / BrazeKitCompat doesn't provide support for this deprecated method. Push notifications support must be integrated using the 'UserNotifications' framework. See our push integration documentation for more details.")
  @objc final public func getActionWithIdentifier(_ identifier: Swift.String, forRemoteNotification userInfo: [Swift.AnyHashable : Any], completionHandler: (() -> Swift.Void)? = nil)
  @available(*, deprecated, message: "renamed to 'notifications.handleUserNotification(response:withCompletionHandler:)'")
  @objc(userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:) final public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: (() -> Swift.Void)? = nil)
  @available(*, deprecated, message: "not needed anymore. Braze automatically retrieves the push notification authorization settings after the user interacts with the permission prompt.")
  @objc final public func pushAuthorization(fromUserNotificationCenter pushAuthGranted: Swift.Bool)
  @available(*, deprecated, message: "SDK metadata must be set using the 'Braze.Configuration' object at SDK initialization")
  @objc final public func addSdkMetadata(_ metadata: [Swift.String])
  @available(*, deprecated, message: "SDK metadata must be set using the 'Braze.Configuration' object at SDK initialization")
  @nonobjc final public func addSdkMetadata(_ metadata: [BrazeKit._COMPAT_ABKSdkMetadata])
  @available(*, deprecated, message: "renamed to 'wipeData()' on the Braze instance")
  @objc final public class func wipeDataAndDisableForAppRun()
  @available(*, deprecated, message: "renamed to the 'enabled' boolean property")
  @objc final public class func disableSDK()
  @available(*, deprecated, message: "use the 'enabled' boolean property to disable / enable the SDK")
  @objc final public class func requestEnableSDKOnNextAppRun()
}
extension BrazeKit.Braze {
  @available(swift, obsoleted: 0.0.1)
  @objc(logCustomEvent:) final public func _objc_logCustomEvent(name: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(logCustomEvent:properties:) final public func _objc_logCustomEvent(name: Swift.String, properties: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:quantity:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, quantity: Swift.Int)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:properties:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, properties: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:quantity:properties:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, quantity: Swift.Int, properties: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(changeUser:) final public func _objc_changeUser(userId: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(changeUser:sdkAuthSignature:) final public func _objc_changeUser(userId: Swift.String, sdkAuthSignature: Swift.String?)
  @available(swift, obsoleted: 0.0.1)
  @objc(requestGeofencesWithLatitude:longitude:) final public func _objc_requestGeofences(latitude: Swift.Double, longitude: Swift.Double)
}
extension BrazeKit.Braze {
  final public func logCustomEvent(name: Swift.String, properties: [Swift.String : Any]? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, quantity: Swift.Int = 1, properties: [Swift.String : Any]? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func changeUser(userId: Swift.String, sdkAuthSignature: Swift.String? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @objc(setSDKAuthenticationSignature:) final public func set(sdkAuthenticationSignature signature: Swift.String)
  @objc final public func requestImmediateDataFlush()
  final public func requestGeofences(latitude: Swift.Double, longitude: Swift.Double, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @objc final public func wipeData()
  @objc(setIdentifierForVendor:) final public func set(identifierForVendor: Swift.String?)
  @objc(setIdentifierForAdvertiser:) final public func set(identifierForAdvertiser: Swift.String?)
  @objc(setAdTrackingEnabled:) final public func set(adTrackingEnabled: Swift.Bool)
  final public func updateTrackingAllowList(adding propertiesToAdd: Swift.Set<BrazeKit.Braze.Configuration.TrackingProperty> = [], removing propertiesToRemove: Swift.Set<BrazeKit.Braze.Configuration.TrackingProperty> = [])
}
@objc public protocol BrazeBannerPlacement {
  @objc var placementId: Swift.String { get }
  @objc(renderWithBanner:) @_Concurrency.MainActor func render(with banner: BrazeKit.Braze.Banner)
  @objc @_Concurrency.MainActor func notifyError(_ error: any Swift.Error)
  @_Concurrency.MainActor @objc optional func removeBannerContent()
}
extension BrazeKit.Braze {
  @objc(prepareForDelayedInitializationWithPushAutomation:analyticsBehavior:) public static func _objc_prepareForDelayedInitialization(pushAutomation: BrazeKit.Braze.Configuration.Push.Automation?, analyticsBehavior: BrazeKit.Braze._OBJC_PushEnqueueBehavior)
  @available(swift, obsoleted: 0.0.1)
  @objc(prepareForDelayedInitialization) public static func _objc_prepareForDelayedInitialization()
  @available(swift, obsoleted: 0.0.1)
  @objc(prepareForDelayedInitializationWithAnalyticsBehavior:) public static func _objc_prepareForDelayedInitialization(analyticsBehavior: BrazeKit.Braze._OBJC_PushEnqueueBehavior)
  @available(swift, obsoleted: 0.0.1)
  @objc(prepareForDelayedInitializationWithPushAutomation:) public static func _objc_prepareForDelayedInitialization(pushAutomation: BrazeKit.Braze.Configuration.Push.Automation?)
  @objc(BRZPushEnqueueBehavior) public enum _OBJC_PushEnqueueBehavior : Swift.Int {
    case queue
    case drop
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze {
  public static func prepareForDelayedInitialization(pushAutomation: BrazeKit.Braze.Configuration.Push.Automation? = nil, analyticsBehavior: BrazeKit.Braze.PushEnqueueBehavior = .queue)
  public enum PushEnqueueBehavior {
    case queue
    case drop
    public static func == (a: BrazeKit.Braze.PushEnqueueBehavior, b: BrazeKit.Braze.PushEnqueueBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@objc(BRZTriggerEvent) public enum _OBJC_TriggerEvent : Swift.Int, Swift.Sendable {
  case sessionStart
  case customEvent
  case purchase
  case other
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(BrazeDelegate) public protocol _OBJC_BrazeDelegate {
  @objc @_Concurrency.MainActor optional func braze(_ braze: BrazeKit.Braze, shouldOpenURL context: BrazeKit.Braze.URLContext) -> Swift.Bool
  @objc @_Concurrency.MainActor optional func braze(_ braze: BrazeKit.Braze, willPresentModalWithContext context: BrazeKit.Braze.ModalContext)
  @objc @_Concurrency.MainActor optional func braze(_ braze: BrazeKit.Braze, noMatchingTriggerForEvent event: BrazeKit._OBJC_TriggerEvent, name: Swift.String?, properties: [Swift.String : Any]?)
}
extension BrazeKit.Braze {
  public enum TriggerEvent : @unchecked Swift.Sendable {
    case sessionStart
    case customEvent(name: Swift.String, properties: [Swift.String : Any]?)
    case purchase(productId: Swift.String, properties: [Swift.String : Any]?)
    case other
    public var identifier: Swift.String? {
      get
    }
  }
}
public protocol BrazeDelegate : AnyObject {
  @_Concurrency.MainActor func braze(_ braze: BrazeKit.Braze, shouldOpenURL context: BrazeKit.Braze.URLContext) -> Swift.Bool
  @_Concurrency.MainActor func braze(_ braze: BrazeKit.Braze, willPresentModalWithContext context: BrazeKit.Braze.ModalContext)
  @_Concurrency.MainActor func braze(_ braze: BrazeKit.Braze, noMatchingTriggerForEvent event: BrazeKit.Braze.TriggerEvent)
}
extension BrazeKit.BrazeDelegate {
  public func braze(_ braze: BrazeKit.Braze, shouldOpenURL context: BrazeKit.Braze.URLContext) -> Swift.Bool
  public func braze(_ braze: BrazeKit.Braze, willPresentModalWithContext context: BrazeKit.Braze.ModalContext)
  public func braze(_ braze: BrazeKit.Braze, noMatchingTriggerForEvent event: BrazeKit.Braze.TriggerEvent)
}
@objc(BrazeInAppMessagePresenter) public protocol _OBJC_BrazeInAppMessagePresenter {
  @objc(presentMessage:) @_Concurrency.MainActor func present(message: BrazeKit.Braze.InAppMessageRaw)
  @objc(dismissWithReason:) @_Concurrency.MainActor optional func dismiss(reason: BrazeKit._OBJC_BrazeInAppMessageDismissalReason)
}
@objc(BRZInAppMessageDismissalReason) public enum _OBJC_BrazeInAppMessageDismissalReason : Swift.Int, Swift.Sendable {
  case wipeData
  case changeUser
  public var reason: BrazeKit.Braze.InAppMessage.DismissalReason {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol BrazeInAppMessagePresenter {
  @_Concurrency.MainActor func present(message: BrazeKit.Braze.InAppMessage)
  @_Concurrency.MainActor func dismiss(reason: BrazeKit.Braze.InAppMessage.DismissalReason)
}
extension BrazeKit.BrazeInAppMessagePresenter {
  public func dismiss(reason: BrazeKit.Braze.InAppMessage.DismissalReason)
}
extension BrazeKit.Braze.InAppMessage {
  public enum DismissalReason : Swift.Sendable {
    case wipeData
    case changeUser
    public static func == (a: BrazeKit.Braze.InAppMessage.DismissalReason, b: BrazeKit.Braze.InAppMessage.DismissalReason) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@objc public protocol BrazeInAppMessageWindowType {
}
@available(iOS 16.1, *)
public protocol BrazeLiveActivityAttributes {
  var brazeActivityId: Swift.String? { get }
}
@objc public protocol BrazeSDKAuthDelegate {
  @objc @_Concurrency.MainActor func braze(_ braze: BrazeKit.Braze, sdkAuthenticationFailedWithError error: BrazeKit.Braze.SDKAuthenticationError)
}
extension BrazeKit.BrazeSDKAuthDelegate {
  public func braze(_ braze: BrazeKit.Braze, sdkAuthenticationFailedWithError error: BrazeKit.Braze.SDKAuthenticationError)
}
@objc(BRZChannel) public enum _OBJC_BRZChannel : Swift.Int, Swift.Sendable {
  case notification
  case inAppMessage
  case contentCard
  case banner
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension BrazeKit.Braze.ModalContext {
  @available(swift, obsoleted: 0.0.1)
  @objc(channel) final public var _objc_channel: BrazeKit._OBJC_BRZChannel {
    @objc get
  }
}
extension BrazeKit.Braze.URLContext {
  @available(swift, obsoleted: 0.0.1)
  @objc(channel) final public var _objc_channel: BrazeKit._OBJC_BRZChannel {
    @objc get
  }
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZCancellable) final public class Cancellable : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc deinit
    @objc final public func cancel()
    @objc public static let empty: BrazeKit.Braze.Cancellable
  }
}
extension BrazeKit.Braze {
  public enum Channel : Swift.String, Swift.Codable, Swift.Sendable {
    case notification
    case inAppMessage
    case contentCard
    case banner
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  @available(swift, obsoleted: 0.0.1)
  @objc(devicePropertyAllowList) final public var _objc_devicePropertyAllowList: [BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty] {
    @objc get
    @objc set
  }
  @_hasMissingDesignatedInitializers @objc(BRZDeviceProperty) final public class _OBJC_BRZDeviceProperty : ObjectiveC.NSObject, Swift.Sendable {
    @objc public static let model: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let osVersion: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let resolution: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let timeZone: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let locale: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let carrier: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let pushEnabled: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let pushAuthStatus: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Api {
  @available(swift, obsoleted: 0.0.1)
  @objc(requestPolicy) final public var _objc_requestPolicy: BrazeKit._OBJC_BRZRequestPolicy {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(sdkFlavor) final public var _objc_sdkFlavor: BrazeKit._OBJC_BRZSDKFlavor {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(sdkMetadata) final public var _objc_sdkMetadata: [BrazeKit._OBJC_BRZSDKMetadata] {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(addSDKMetadata:) final public func _objc_addSDKMetadata(_ sdkMetadata: [BrazeKit._OBJC_BRZSDKMetadata])
  @available(swift, obsoleted: 0.0.1)
  @objc(trackingPropertyAllowList) final public var _objc_trackingPropertyAllowList: Swift.Set<BrazeKit._OBJC_BRZTrackingProperty> {
    @objc get
    @objc set(newList)
  }
}
@objc(BRZRequestPolicy) public enum _OBJC_BRZRequestPolicy : Swift.Int, Swift.Sendable {
  case automatic
  case manual
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(BRZSDKFlavor) public enum _OBJC_BRZSDKFlavor : Swift.Int, Swift.Sendable {
  case vanilla
  case unity
  case react
  case cordova
  case xamarin
  case flutter
  case segment
  case mparticle
  case tealium
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(BRZSDKMetadata) final public class _OBJC_BRZSDKMetadata : ObjectiveC.NSObject, Swift.Sendable {
  @objc public static let adjust: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let airbridge: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let applevisionpro: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let appsflyer: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let bluedot: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let branch: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let cordova: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let carthage: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let cocoapods: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let cordovapm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let expo: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let foursquare: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let flutter: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let googletagmanager: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let gimbal: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let gradle: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let ionic: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let kochava: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let manual: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let maccatalyst: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let mparticle: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let nativescript: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let npm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let nuget: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let pub: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let radar: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let reactnative: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let reactnativenewarch: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let segment: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let singular: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let swiftpm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let tealium: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let unreal: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let unitypm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let unity: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let vizbee: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let xamarin: BrazeKit._OBJC_BRZSDKMetadata
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZConfiguration) final public class Configuration : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc final public var api: BrazeKit.Braze.Configuration.Api {
      @objc get
      @objc set
    }
    @objc final public var push: BrazeKit.Braze.Configuration.Push {
      @objc get
      @objc set
    }
    @objc final public var location: BrazeKit.Braze.Configuration.Location {
      @objc get
      @objc set
    }
    @objc final public var logger: BrazeKit.Braze.Configuration.Logger {
      @objc get
      @objc set
    }
    @objc final public var sessionTimeout: Foundation.TimeInterval {
      @objc get
      @objc set
    }
    @objc final public var triggerMinimumTimeInterval: Foundation.TimeInterval {
      @objc get
      @objc set
    }
    final public var devicePropertyAllowList: Swift.Set<BrazeKit.Braze.Configuration.DeviceProperty> {
      get
      set
    }
    @objc final public var useUUIDAsDeviceId: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var forwardUniversalLinks: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var optInWhenPushAuthorized: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var tvOSPersistedSizeLimit: Swift.UInt64 {
      @objc get
      @objc set
    }
    @objc final public var preventInAppMessageDisplayForDifferentUser: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var ephemeralEvents: [Swift.String] {
      @objc get
      @objc set
    }
    @objc public init(apiKey: Swift.String, endpoint: Swift.String)
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationApi) final public class Api : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc final public var key: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var endpoint: Swift.String? {
      @objc get
      @objc set
    }
    final public var requestPolicy: BrazeKit.Braze.Configuration.Api.RequestPolicy {
      get
      set
    }
    @objc final public var flushInterval: Foundation.TimeInterval {
      @objc get
      @objc set
    }
    @objc final public var sdkAuthentication: Swift.Bool {
      @objc get
      @objc set
    }
    final public var sdkFlavor: BrazeKit.Braze.Configuration.Api.SDKFlavor {
      get
      set
    }
    final public var sdkMetadata: Swift.Set<BrazeKit.Braze.Configuration.Api.SDKMetadata> {
      get
    }
    final public var trackingPropertyAllowList: Swift.Set<BrazeKit.Braze.Configuration.TrackingProperty> {
      get
      set
    }
    final public func addSDKMetadata(_ sdkMetadata: [BrazeKit.Braze.Configuration.Api.SDKMetadata])
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Api {
  public enum RequestPolicy : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
    case automatic
    case manual
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Api.RequestPolicy]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [BrazeKit.Braze.Configuration.Api.RequestPolicy] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SDKFlavor : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
    case vanilla
    case unity
    case react
    case cordova
    case xamarin
    case flutter
    case segment
    case mparticle
    case tealium
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Api.SDKFlavor]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [BrazeKit.Braze.Configuration.Api.SDKFlavor] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SDKMetadata : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
    case adjust
    case airbridge
    case applevisionpro
    case appsflyer
    case bluedot
    case branch
    case cordova
    case carthage
    case cocoapods
    case cordovapm
    case expo
    case foursquare
    case flutter
    case googletagmanager
    case gimbal
    case gradle
    case ionic
    case kochava
    case manual
    case maccatalyst
    case mparticle
    case nativescript
    case npm
    case nuget
    case pub
    case radar
    case reactnative
    case reactnativenewarch
    case segment
    case singular
    case swiftpm
    case tealium
    case unreal
    case unitypm
    case unity
    case vizbee
    case xamarin
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Api.SDKMetadata]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [BrazeKit.Braze.Configuration.Api.SDKMetadata] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  public enum DeviceProperty : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
    case model
    case osVersion
    case resolution
    case timeZone
    case locale
    case carrier
    case pushEnabled
    case pushAuthStatus
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.DeviceProperty]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [BrazeKit.Braze.Configuration.DeviceProperty] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationLocation) final public class Location : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc final public var automaticLocationCollection: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var geofencesEnabled: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var automaticGeofenceRequests: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var allowBackgroundGeofenceUpdates: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var distanceFilter: Swift.Double {
      @objc get
      @objc set
    }
    @objc final public var brazeLocationProvider: Swift.AnyObject? {
      @objc get
      @objc set
    }
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationLogger) final public class Logger : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc final public var level: BrazeKit.Braze.Configuration.Logger.Level {
      @objc get
      @objc set
    }
    @objc final public var signposts: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var print: ((_ message: Swift.String, _ level: BrazeKit.Braze.Configuration.Logger.Level) -> Swift.Bool)? {
      @objc get
      @objc set
    }
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Logger {
  @objc(BRZLoggerLevel) public enum Level : Swift.UInt8, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
    case debug
    case info
    case error
    case disabled = 255
    public init?(rawValue: Swift.UInt8)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Logger.Level]
    public typealias RawValue = Swift.UInt8
    nonisolated public static var allCases: [BrazeKit.Braze.Configuration.Logger.Level] {
      get
    }
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationPush) final public class Push : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc final public var appGroup: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var automation: BrazeKit.Braze.Configuration.Push.Automation {
      @objc get
      @objc set
    }
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Push {
  @objc(BRZConfigurationPushAutomation) final public class Automation : ObjectiveC.NSObject, Swift.ExpressibleByBooleanLiteral, @unchecked Swift.Sendable {
    @objc public static let defaultForegroundPresentationOptions: UserNotifications.UNNotificationPresentationOptions
    @objc final public var automaticSetup: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var requestAuthorizationAtLaunch: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var authorizationOptions: UserNotifications.UNAuthorizationOptions {
      @objc get
      @objc set
    }
    @objc final public var foregroundPresentationOptions: UserNotifications.UNNotificationPresentationOptions {
      @objc get
      @objc set
    }
    @objc final public var setNotificationCategories: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var registerDeviceToken: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var handleBackgroundNotification: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var handleNotificationResponse: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var willPresentNotification: Swift.Bool {
      @objc get
      @objc set
    }
    @objc public init(automaticSetup: Swift.Bool = false, requestAuthorizationAtLaunch: Swift.Bool = false, authorizationOptions: UserNotifications.UNAuthorizationOptions = [.badge, .sound, .alert], foregroundPresentationOptions: UserNotifications.UNNotificationPresentationOptions = Automation
        .defaultForegroundPresentationOptions, setNotificationCategories: Swift.Bool = false, registerDeviceToken: Swift.Bool = false, handleBackgroundNotification: Swift.Bool = false, handleNotificationResponse: Swift.Bool = false, willPresentNotification: Swift.Bool = false)
    convenience required public init(booleanLiteral value: Swift.BooleanLiteralType)
    @available(swift, obsoleted: 0.0.1)
    @objc(initEnablingAllAutomations:) convenience public init(enablingAllAutomations enabled: Swift.Bool)
    public typealias BooleanLiteralType = Swift.BooleanLiteralType
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers @objc(BRZTrackingProperty) final public class _OBJC_BRZTrackingProperty : ObjectiveC.NSObject, Swift.Sendable {
  @objc public static let deviceData: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let firstName: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let lastName: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let email: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let dateOfBirth: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let country: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let language: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let homeCity: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let gender: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let phoneNumber: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let emailSubscriptionState: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let notificationSubscriptionState: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let attributionData: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let pushToken: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let pushToStartTokens: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static func customAttribute(attributes: Swift.Set<Swift.String>) -> BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let allCustomAttributes: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let analyticsEvents: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let purchases: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static func customEvent(events: Swift.Set<Swift.String>) -> BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let allCustomEvents: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let everything: BrazeKit._OBJC_BRZTrackingProperty
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension BrazeKit.Braze.Configuration {
  public enum TrackingProperty : Swift.Hashable, Swift.Sendable {
    case deviceData
    case firstName, lastName, email, dateOfBirth, country, language, homeCity, gender, phoneNumber, emailSubscriptionState, notificationSubscriptionState, attributionData, pushToken, pushToStartTokens
    case customAttribute(Swift.Set<Swift.String>)
    case allCustomAttributes
    case analyticsEvents
    case purchases
    case customEvent(Swift.Set<Swift.String>)
    case allCustomEvents
    case everything
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.Configuration.TrackingProperty, b: BrazeKit.Braze.Configuration.TrackingProperty) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze {
  indirect public enum ContentCard : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    case classic(BrazeKit.Braze.ContentCard.Classic)
    case classicImage(BrazeKit.Braze.ContentCard.ClassicImage)
    case imageOnly(BrazeKit.Braze.ContentCard.ImageOnly)
    case captionedImage(BrazeKit.Braze.ContentCard.CaptionedImage)
    case control(BrazeKit.Braze.ContentCard.Control)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard, b: BrazeKit.Braze.ContentCard) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCard {
  public var classic: BrazeKit.Braze.ContentCard.Classic? {
    get
    set
  }
  public var classicImage: BrazeKit.Braze.ContentCard.ClassicImage? {
    get
    set
  }
  public var imageOnly: BrazeKit.Braze.ContentCard.ImageOnly? {
    get
    set
  }
  public var captionedImage: BrazeKit.Braze.ContentCard.CaptionedImage? {
    get
    set
  }
  public var control: BrazeKit.Braze.ContentCard.Control? {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public var imageURL: Foundation.URL? {
    get
  }
}
extension BrazeKit.Braze.ContentCardRaw.Context {
  @objc convenience dynamic public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping () -> Swift.Void, processClickAction: @escaping (_ url: Foundation.URL, _ useWebView: Swift.Bool) -> Swift.Void, logDismissed: @escaping () -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, loadImage: ((@escaping @_Concurrency.MainActor @Sendable (Foundation.URL?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable)?)
  @objc convenience dynamic public init?(cardRaw: BrazeKit.Braze.ContentCardRaw, using braze: BrazeKit.Braze)
  @available(swift, obsoleted: 0.0.1)
  @objc(loadImageWithCompletion:) final public func _objc_loadImage(completion: @escaping (Foundation.URL?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze.ContentCard {
  public typealias Context = BrazeKit.Braze.ContentCardRaw.Context
}
extension BrazeKit.Braze.ContentCardRaw {
  @objc(BRZContentCardContext) final public class Context : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping () -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.ContentCard.ClickAction) -> Swift.Void, logDismissed: @escaping () -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, loadImage: ((@escaping @_Concurrency.MainActor @Sendable (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable)?)
    convenience public init(card: BrazeKit.Braze.ContentCard, using braze: BrazeKit.Braze)
    @objc final public func logImpression()
    @objc final public func logClick()
    final public func processClickAction(_ clickAction: BrazeKit.Braze.ContentCard.ClickAction)
    @objc(processClickActionWithURL:useWebView:) final public func processClickAction(url: Foundation.URL, useWebView: Swift.Bool)
    @objc final public func logDismissed()
    @objc final public func logError(_ error: any Swift.Error)
    final public let loadImage: ((_ completion: @escaping @_Concurrency.MainActor @Sendable (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable)?
    @objc deinit
  }
}
extension BrazeKit.Braze.ContentCard {
  public struct Data : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var id: Swift.String
    public var clickAction: BrazeKit.Braze.ContentCard.ClickAction?
    public var viewed: Swift.Bool
    public var dismissible: Swift.Bool
    public var removed: Swift.Bool
    public var pinned: Swift.Bool
    public var clicked: Swift.Bool
    public var test: Swift.Bool
    public var createdAt: Foundation.TimeInterval
    public var expiresAt: Foundation.TimeInterval
    public var extras: [Swift.String : Any] {
      get
      set
    }
    public var context: BrazeKit.Braze.ContentCard.Context?
    public init(id: Swift.String = UUID().uuidString, clickAction: BrazeKit.Braze.ContentCard.ClickAction? = nil, viewed: Swift.Bool = false, dismissible: Swift.Bool = false, removed: Swift.Bool = false, pinned: Swift.Bool = false, clicked: Swift.Bool = false, test: Swift.Bool = false, createdAt: Foundation.TimeInterval = 0, expiresAt: Foundation.TimeInterval = -1, extras: [Swift.String : Any] = [:])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.Data, b: BrazeKit.Braze.ContentCard.Data) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@dynamicMemberLookup public protocol BrazeContentCardDataLookup {
  var data: BrazeKit.Braze.ContentCard.Data { get set }
  subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.ContentCard.Data, Value>) -> Value { get set }
}
extension BrazeKit.BrazeContentCardDataLookup {
  public subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.ContentCard.Data, Value>) -> Value {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public var data: BrazeKit.Braze.ContentCard.Data {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public var title: Swift.String? {
    get
    set
  }
  public var description: Swift.String? {
    get
    set
  }
  public var domain: Swift.String? {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public func json() -> Foundation.Data?
  public static func decoding(json: Foundation.Data) -> BrazeKit.Braze.ContentCard?
}
extension BrazeKit.Braze.ContentCard {
  public func logImpression(using braze: BrazeKit.Braze)
  public func logClick(using braze: BrazeKit.Braze)
  public func logDismissed(using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.ContentCardRaw {
  @available(swift, obsoleted: 0.0.1)
  @objc(type) final public var _objc_type: BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(imageAspectRatio) final public var _objc_imageAspectRatio: Swift.Double {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.ContentCardRaw {
  @objc final public func logImpression(using braze: BrazeKit.Braze)
  @objc final public func logClick(using braze: BrazeKit.Braze)
  @objc final public func logDismissed(using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.ContentCardRaw {
  @objc(BRZContentCardRawType) public enum _OBJC_BRZContentCardRawType : Swift.Int, Swift.Sendable {
    case classic
    case imageOnly
    case captionedImage
    case control
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZContentCardRaw) final public class ContentCardRaw : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    @objc(identifier) final public var id: Swift.String {
      @objc get
      @objc set
    }
    final public var type: BrazeKit.Braze.ContentCardRaw.CardType {
      get
      set
    }
    @objc final public var image: Foundation.URL? {
      @objc get
      @objc set
    }
    @objc final public var imageAltText: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var language: Swift.String? {
      @objc get
      @objc set
    }
    final public var imageAspectRatio: Swift.Double? {
      get
      set
    }
    @objc final public var title: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var cardDescription: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var domain: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var url: Foundation.URL? {
      @objc get
      @objc set
    }
    @objc final public var useWebView: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var extras: [Swift.String : Any] {
      @objc get
      @objc set
    }
    @objc final public var viewed: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var dismissible: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var removed: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var pinned: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var clicked: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var test: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var createdAt: Foundation.TimeInterval {
      @objc get
      @objc set
    }
    @objc final public var expiresAt: Foundation.TimeInterval {
      @objc get
      @objc set
    }
    @objc final public var context: BrazeKit.Braze.ContentCard.Context? {
      @objc get
      @objc set
    }
    @objc final public func json() -> Foundation.Data?
    @objc public static func decoding(json: Foundation.Data) -> Self?
    @objc override dynamic public init()
    public init(_ card: BrazeKit.Braze.ContentCard)
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCardRaw {
  public enum CardType : Swift.String, Swift.Codable, Swift.Sendable {
    case classic
    case imageOnly
    case captionedImage
    case control
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.ContentCard {
  public init(_ card: BrazeKit.Braze.ContentCardRaw) throws
}
extension BrazeKit.Braze.ContentCard {
  public struct Classic : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var language: Swift.String?
    public var title: Swift.String
    public var description: Swift.String
    public var domain: Swift.String?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), language: Swift.String? = nil, title: Swift.String, description: Swift.String, domain: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.Classic, b: BrazeKit.Braze.ContentCard.Classic) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ClassicImage : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var image: Foundation.URL
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var title: Swift.String
    public var description: Swift.String
    public var domain: Swift.String?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), image: Foundation.URL, imageAltText: Swift.String? = nil, language: Swift.String? = nil, title: Swift.String, description: Swift.String, domain: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.ClassicImage, b: BrazeKit.Braze.ContentCard.ClassicImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ImageOnly : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var image: Foundation.URL
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var imageAspectRatio: Swift.Double?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), image: Foundation.URL, imageAltText: Swift.String? = nil, language: Swift.String? = nil, imageAspectRatio: Swift.Double? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.ImageOnly, b: BrazeKit.Braze.ContentCard.ImageOnly) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CaptionedImage : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var image: Foundation.URL
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var imageAspectRatio: Swift.Double?
    public var title: Swift.String
    public var description: Swift.String
    public var domain: Swift.String?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), image: Foundation.URL, imageAltText: Swift.String? = nil, language: Swift.String? = nil, imageAspectRatio: Swift.Double? = nil, title: Swift.String, description: Swift.String, domain: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.CaptionedImage, b: BrazeKit.Braze.ContentCard.CaptionedImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Control : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public init(data: BrazeKit.Braze.ContentCard.Data = .init())
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.Control, b: BrazeKit.Braze.ContentCard.Control) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCard {
  public enum ClickAction : Swift.Hashable, Swift.Codable, Swift.Sendable {
    case url(Foundation.URL, useWebView: Swift.Bool)
    public var url: Foundation.URL? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.ClickAction, b: BrazeKit.Braze.ContentCard.ClickAction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCards {
  @available(swift, obsoleted: 0.0.1)
  @objc(cards) final public var _objc_cards: [BrazeKit.Braze.ContentCardRaw] {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(unviewedCards) final public var _objc_unviewedCards: [BrazeKit.Braze.ContentCardRaw] {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefresh) final public func _objc_requestRefresh()
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefreshWithCompletion:) final public func _objc_requestRefresh(_ completion: @escaping @_Concurrency.MainActor ([BrazeKit.Braze.ContentCardRaw]?, (any Swift.Error)?) -> Swift.Void)
  @available(swift, obsoleted: 0.0.1)
  @objc(subscribeToUpdates:) final public func _objc_subscribeToUpdates(_ update: @escaping @_Concurrency.MainActor ([BrazeKit.Braze.ContentCardRaw]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZContentCards) final public class ContentCards : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    final public var cards: [BrazeKit.Braze.ContentCard] {
      get
    }
    final public var unviewedCards: [BrazeKit.Braze.ContentCard] {
      get
    }
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public var cardsStream: _Concurrency.AsyncStream<[BrazeKit.Braze.ContentCard]> {
      get
    }
    @objc final public var lastUpdate: Foundation.Date? {
      @objc get
    }
    final public func requestRefresh(_ completion: (@_Concurrency.MainActor (Swift.Result<[BrazeKit.Braze.ContentCard], any Swift.Error>) -> Swift.Void)? = nil)
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    @discardableResult
    final public func requestRefresh() async throws -> [BrazeKit.Braze.ContentCard]
    final public func subscribeToUpdates(_ update: @escaping @_Concurrency.MainActor ([BrazeKit.Braze.ContentCard]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Api {
  @available(*, unavailable, renamed: "SDKMetadata")
  public typealias SdkMetadata = BrazeKit.Braze.Configuration.Api.SDKMetadata
  @available(*, unavailable, renamed: "addSDKMetadata(_:)")
  final public func addSdkMetadata(_ sdkMetadata: [BrazeKit.Braze.Configuration.Api.SDKMetadata])
}
extension BrazeKit.Braze.InAppMessage.Themes {
  @available(*, unavailable, renamed: "defaults")
  public static let `default`: BrazeKit.Braze.InAppMessage.Themes
}
extension BrazeKit.Braze.ContentCard.ClickAction {
  @available(*, unavailable, renamed: "url(_:useWebView:)")
  public static func uri(_ uri: Foundation.URL, useWebView: Swift.Bool) -> BrazeKit.Braze.ContentCard.ClickAction
  @available(*, unavailable, renamed: "url")
  public var uri: Foundation.URL? {
    get
  }
}
extension BrazeKit.Braze.InAppMessage.ClickAction {
  @available(*, unavailable, renamed: "url(_:useWebView:)")
  public static func uri(_ uri: Foundation.URL, useWebView: Swift.Bool) -> BrazeKit.Braze.InAppMessage.ClickAction
  @available(*, unavailable, renamed: "url")
  public var uri: Foundation.URL? {
    get
  }
}
extension BrazeKit.Braze.InAppMessage.ModalImage {
  @available(*, unavailable, renamed: "imageURL")
  public var imageUri: Foundation.URL {
    get
    set
  }
}
extension BrazeKit.Braze.InAppMessage.Full {
  @available(*, unavailable, renamed: "imageURL")
  public var imageUri: Foundation.URL {
    get
    set
  }
}
extension BrazeKit.Braze.InAppMessage.FullImage {
  @available(*, unavailable, renamed: "imageURL")
  public var imageUri: Foundation.URL {
    get
    set
  }
}
extension BrazeKit.Braze.Configuration.Api {
  @available(*, unavailable, renamed: "SDKFlavor")
  public typealias Flavor = BrazeKit.Braze.Configuration.Api.SDKFlavor
  @available(*, unavailable, renamed: "sdkFlavor")
  final public var flavor: BrazeKit.Braze.Configuration.Api.SDKFlavor {
    get
    set
  }
}
extension BrazeKit.Braze {
  @available(*, unavailable, renamed: "deviceId")
  @objc(deviceIdOnQueue:completion:) final public func deviceId(queue: Dispatch.DispatchQueue = .main, completion: @escaping (Swift.String) -> Swift.Void)
  @available(*, unavailable, renamed: "deviceId")
  @available(swift, obsoleted: 0.0.1)
  @objc(deviceIdWithCompletion:) final public func _objc_deviceId(completion: @escaping (Swift.String) -> Swift.Void)
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
  @available(*, unavailable, renamed: "deviceId")
  final public func deviceId() async -> Swift.String
}
extension BrazeKit.Braze.User {
  @available(*, unavailable, renamed: "setCustomAttribute")
  final public func setCustomAttributeArray(key: Swift.String, array: [Swift.String]?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @available(*, unavailable, renamed: "addToCustomAttributeStringArray")
  final public func addToCustomAttributeArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @available(*, unavailable, renamed: "removeFromCustomAttributeStringArray")
  final public func removeFromCustomAttributeArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @available(swift, obsoleted: 0.0.1)
  @available(*, unavailable, renamed: "addToCustomAttributeStringArrayWithKey")
  @objc(addToCustomAttributeArrayWithKey:value:) final public func _objc_addToCustomAttributeArray(key: Swift.String, value: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @available(*, unavailable, renamed: "removeFromCustomAttributeStringArrayWithKey")
  @objc(removeFromCustomAttributeArrayWithKey:value:) final public func _objc_removeFromCustomAttributeArray(key: Swift.String, value: Swift.String)
}
extension BrazeKit.Braze.Configuration.Location {
  @available(*, unavailable, renamed: "brazeLocationProvider")
  @objc final public var brazeLocation: Swift.AnyObject? {
    @objc get
    @objc set
  }
}
public var overrideResourceBundle: Foundation.Bundle? {
  get
  set
}
extension BrazeKit.Braze {
  @available(*, deprecated, renamed: "Braze.Resources.acknowledgments")
  @objc public static var acknowledgments: [Swift.String : Foundation.URL]
  @available(*, deprecated, renamed: "Braze.Resources.license")
  @objc public static var license: Foundation.URL?
}
extension BrazeKit.Braze.FeatureFlag {
  @available(*, deprecated, renamed: "jsonProperty(key:)")
  final public func jsonObjectProperty(key: Swift.String) -> [Swift.String : Any]?
  @available(*, deprecated)
  final public func jsonStringProperty(key: Swift.String) -> Swift.String?
  @available(*, deprecated, renamed: "jsonPropertyForKey")
  @objc(jsonObjectPropertyForKey:) final public func _objc_jsonObjectProperty(key: Swift.String) -> Foundation.NSDictionary?
}
extension BrazeKit.Braze {
  @available(*, deprecated, renamed: "prepareForDelayedInitialization")
  @objc public static func _prepareForDelayedInitialization(pushAutomation: BrazeKit.Braze.Configuration.Push.Automation? = nil)
  @available(*, deprecated, renamed: "prepareForDelayedInitialization")
  @available(swift, obsoleted: 0.0.1)
  @objc(_prepareForDelayedInitialization) public static func _OBJC__prepareForDelayedInitialization()
}
extension BrazeKit.Braze.WebViewBridge.QueryHandler {
  @available(*, deprecated, renamed: "processInAppMessageURL(_:logBodyClick:)")
  public func process(url: Foundation.URL, logBodyClick: Swift.Bool = true) -> (BrazeKit.Braze.InAppMessage.ClickAction, Swift.String?)
}
extension BrazeKit.Braze.ContentCardRaw {
  @available(*, deprecated, renamed: "decoding(json:)")
  @objc public static func from(json: Foundation.Data) -> BrazeKit.Braze.ContentCardRaw?
}
extension BrazeKit.Braze.User {
  @available(*, deprecated, renamed: "id")
  @objc(idOnQueue:completion:) final public func id(queue: Dispatch.DispatchQueue = .main, completion: @escaping (Swift.String?) -> Swift.Void)
  @available(*, deprecated, renamed: "id")
  @objc(idWithCompletion:) final public func _objc_id(completion: @escaping (Swift.String?) -> Swift.Void)
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
  @available(*, deprecated, renamed: "id")
  final public func id() async -> Swift.String?
}
extension BrazeKit.Braze {
  public struct ErrorString : Swift.Error, Swift.Hashable, Swift.Sendable {
    public init(_ error: any Swift.Error)
    public init(_ error: Swift.String)
    public var logDescription: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ErrorString, b: BrazeKit.Braze.ErrorString) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze.FeatureFlag {
  @available(swift, obsoleted: 0.0.1)
  @objc(properties) final public var _objc_properties: [Swift.String : Any] {
    @objc get
  }
  @objc(numberPropertyForKey:) final public func _objc_numberProperty(key: Swift.String) -> Foundation.NSNumber?
  @objc(timestampPropertyForKey:) final public func _objc_timestampProperty(key: Swift.String) -> Foundation.NSNumber?
  @objc(boolPropertyForKey:) final public func _objc_boolProperty(key: Swift.String) -> Foundation.NSNumber?
  @objc(jsonPropertyForKey:) final public func _objc_jsonProperty(key: Swift.String) -> Foundation.NSDictionary?
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZFeatureFlag) final public class FeatureFlag : ObjectiveC.NSObject, Swift.Identifiable, Swift.Codable, @unchecked Swift.Sendable {
    @objc(identifier) final public var id: Swift.String {
      @objc get
    }
    @objc final public var enabled: Swift.Bool {
      @objc get
    }
    final public var properties: [Swift.String : Any] {
      get
    }
    @objc final public var flagTrackingString: Swift.String? {
      @objc get
    }
    @objc(stringPropertyForKey:) final public func stringProperty(key: Swift.String) -> Swift.String?
    final public func numberProperty(key: Swift.String) -> Swift.Double?
    final public func timestampProperty(key: Swift.String) -> Swift.Int?
    final public func boolProperty(key: Swift.String) -> Swift.Bool?
    @objc(imagePropertyForKey:) final public func imageProperty(key: Swift.String) -> Swift.String?
    final public func jsonProperty(key: Swift.String) -> [Swift.String : Any]?
    final public func jsonProperty<T>(key: Swift.String, type: T.Type, decoder: Foundation.JSONDecoder = JSONDecoder()) -> T? where T : Swift.Decodable
    @objc override dynamic public init()
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias ID = Swift.String
    @objc deinit
  }
}
extension BrazeKit.Braze.FeatureFlag {
  @objc final public func json() -> Foundation.Data?
  @objc public static func decoding(json: Foundation.Data) -> Self?
}
extension BrazeKit.Braze.FeatureFlags {
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefresh) final public func _objc_requestRefresh()
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefreshWithCompletion:) final public func _objc_requestRefresh(_ completion: @escaping @_Concurrency.MainActor ([BrazeKit.Braze.FeatureFlag]?, (any Swift.Error)?) -> Swift.Void)
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZFeatureFlags) final public class FeatureFlags : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc final public var featureFlags: [BrazeKit.Braze.FeatureFlag] {
      @objc get
    }
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public var featureFlagsStream: _Concurrency.AsyncStream<[BrazeKit.Braze.FeatureFlag]> {
      get
    }
    @objc final public func featureFlag(id: Swift.String) -> BrazeKit.Braze.FeatureFlag?
    final public func requestRefresh(_ completion: (@_Concurrency.MainActor (Swift.Result<[BrazeKit.Braze.FeatureFlag], any Swift.Error>) -> Swift.Void)? = nil)
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    @discardableResult
    final public func requestRefresh() async throws -> [BrazeKit.Braze.FeatureFlag]
    @objc final public func subscribeToUpdates(_ update: @escaping @_Concurrency.MainActor ([BrazeKit.Braze.FeatureFlag]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc final public func logFeatureFlagImpression(id: Swift.String)
    @objc deinit
  }
}
extension Foundation.NSRecursiveLock {
  @discardableResult
  @inlinable public func sync<R>(work: () throws -> R) rethrows -> R {
    self.lock()
    defer { self.unlock() }
    return try work()
  }
}
extension BrazeKit.Braze {
  indirect public enum InAppMessage : BrazeKit.BrazeInAppMessageDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    case slideup(BrazeKit.Braze.InAppMessage.Slideup)
    case modal(BrazeKit.Braze.InAppMessage.Modal)
    case modalImage(BrazeKit.Braze.InAppMessage.ModalImage)
    case full(BrazeKit.Braze.InAppMessage.Full)
    case fullImage(BrazeKit.Braze.InAppMessage.FullImage)
    case html(BrazeKit.Braze.InAppMessage.Html)
    case control(BrazeKit.Braze.InAppMessage.Control)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage, b: BrazeKit.Braze.InAppMessage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessage {
  public var slideup: BrazeKit.Braze.InAppMessage.Slideup? {
    get
    set
  }
  public var modal: BrazeKit.Braze.InAppMessage.Modal? {
    get
    set
  }
  public var modalImage: BrazeKit.Braze.InAppMessage.ModalImage? {
    get
    set
  }
  public var full: BrazeKit.Braze.InAppMessage.Full? {
    get
    set
  }
  public var fullImage: BrazeKit.Braze.InAppMessage.FullImage? {
    get
    set
  }
  public var html: BrazeKit.Braze.InAppMessage.Html? {
    get
    set
  }
  public var control: BrazeKit.Braze.InAppMessage.Control? {
    get
    set
  }
}
@objc(BRZInAppMessageUserIDMatchBehavior) public enum _objc_BRZInAppMessageUserIDMatchBehavior : Swift.Int {
  case ignore
  case enforce
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension BrazeKit.Braze.InAppMessageRaw.Context {
  @available(swift, obsoleted: 0.0.1)
  @objc(userID) final public var _objc_userId: Swift.String? {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(userIDMatchBehavior) final public var _objc_userIDMatchBehavior: BrazeKit._objc_BRZInAppMessageUserIDMatchBehavior {
    @objc get
  }
  @objc convenience dynamic public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping (_ buttonId: Swift.String?) -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, Foundation.URL?, Any?) -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, braze: @escaping () -> Any?, getLocalAssets: @escaping ([Foundation.URL], Foundation.URL, @escaping ([Foundation.URL : Foundation.URL]?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable, withLocalAssets: @escaping (BrazeKit.Braze.InAppMessageRaw, Foundation.URL, @escaping (BrazeKit.Braze.InAppMessageRaw?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable, multipleLogClickEnabled: Swift.Bool)
  @objc convenience dynamic public init(userID: Swift.String?, userIDMatchBehavior: BrazeKit._objc_BRZInAppMessageUserIDMatchBehavior, logImpression: @escaping () -> Swift.Void, logClick: @escaping (_ buttonId: Swift.String?) -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, Foundation.URL?, Any?) -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, braze: @escaping () -> Any?, getLocalAssets: @escaping ([Foundation.URL], Foundation.URL, @escaping ([Foundation.URL : Foundation.URL]?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable, withLocalAssets: @escaping (BrazeKit.Braze.InAppMessageRaw, Foundation.URL, @escaping (BrazeKit.Braze.InAppMessageRaw?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable, multipleLogClickEnabled: Swift.Bool)
  @objc convenience dynamic public init?(messageRaw: BrazeKit.Braze.InAppMessageRaw, using braze: BrazeKit.Braze)
  @objc convenience dynamic public init?(messageRaw: BrazeKit.Braze.InAppMessageRaw, using braze: BrazeKit.Braze, userID: Swift.String?, userIDMatchBehavior: BrazeKit._objc_BRZInAppMessageUserIDMatchBehavior)
  @available(swift, obsoleted: 0.0.1)
  @objc(logClick) final public func _objc_logClick()
  @available(swift, obsoleted: 0.0.1)
  @objc(logClickWithButtonId:) final public func _objc_logClick(buttonId: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(processClickAction:url:useWebView:) final public func _objc_processClickAction(_ clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc(processClickAction:url:useWebView:target:) final public func _objc_processClickAction(_ clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool, target: Any? = nil)
  @available(swift, obsoleted: 0.0.1)
  @objc(getLocalAssets:destinationURL:completionHandler:) final public func _objc_getLocalAssets(urls: [Foundation.URL], destinationURL: Foundation.URL, completionHandler: @escaping ([Foundation.URL : Foundation.URL]?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable
  @available(swift, obsoleted: 0.0.1)
  @objc(withLocalAssets:destinationURL:completionHandler:) final public func _objc_withLocalAssets(message: BrazeKit.Braze.InAppMessageRaw, destinationURL: Foundation.URL, completionHandler: @escaping (BrazeKit.Braze.InAppMessageRaw?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze.InAppMessage {
  public typealias Context = BrazeKit.Braze.InAppMessageRaw.Context
}
extension BrazeKit.Braze.InAppMessageRaw {
  @objc(BRZInAppMessageContext) final public class Context : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    public enum Error : Swift.Error, Swift.Hashable, Swift.Sendable {
      case noLogImpression
      case extraLogImpression
      case extraLogClick
      case processClickActionMissingUri
      public static func == (a: BrazeKit.Braze.InAppMessageRaw.Context.Error, b: BrazeKit.Braze.InAppMessageRaw.Context.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum UserIDMatchBehavior {
      case ignore
      case enforce(userID: Swift.String?)
    }
    @objc final public var valid: Swift.Bool {
      @objc get
    }
    @objc final public var braze: Any? {
      @objc get
    }
    final public let userIDMatchBehavior: BrazeKit.Braze.InAppMessageRaw.Context.UserIDMatchBehavior
    public init(userIDMatchBehavior: BrazeKit.Braze.InAppMessageRaw.Context.UserIDMatchBehavior = .ignore, logImpression: @escaping () -> Swift.Void, logClick: @escaping (_ buttonId: Swift.String?) -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.InAppMessage.ClickAction, Any?) -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, braze: @escaping () -> Any?, getLocalAssets: @escaping ([Foundation.URL], Foundation.URL, @escaping ((Swift.Result<[Foundation.URL : Foundation.URL], any Swift.Error>) -> Swift.Void)) -> BrazeKit.Braze.Cancellable, withLocalAssets: @escaping (BrazeKit.Braze.InAppMessage, Foundation.URL, @escaping (Swift.Result<BrazeKit.Braze.InAppMessage, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable, multipleLogClickEnabled: Swift.Bool)
    convenience public init(message: BrazeKit.Braze.InAppMessage, using braze: BrazeKit.Braze, userIDMatchBehavior: BrazeKit.Braze.InAppMessageRaw.Context.UserIDMatchBehavior = .ignore)
    @objc final public func logImpression()
    final public func logClick(buttonId: Swift.String? = nil)
    final public func processClickAction(_ clickAction: BrazeKit.Braze.InAppMessage.ClickAction, target: Any? = nil)
    final public func processClickAction(_ clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction, url: Foundation.URL?, useWebView: Swift.Bool, target: Any? = nil)
    @objc final public func logError(_ error: any Swift.Error)
    @objc(logErrorFlattened:) final public func logError(flattened error: Swift.String)
    final public func getLocalAssets(urls: [Foundation.URL], destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<[Foundation.URL : Foundation.URL], any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    final public func withLocalAssets(message: BrazeKit.Braze.InAppMessage, destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<BrazeKit.Braze.InAppMessage, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc final public func discard()
    @objc deinit
  }
}
extension BrazeKit.Braze.InAppMessage {
  public struct Data : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var id: Swift.String?
    public var clickAction: BrazeKit.Braze.InAppMessage.ClickAction
    public var messageClose: BrazeKit.Braze.InAppMessage.MessageClose
    public var orientation: BrazeKit.Braze.InAppMessage.Orientation
    public var animateIn: Swift.Bool
    public var animateOut: Swift.Bool
    public var isTestSend: Swift.Bool {
      get
    }
    public var extras: [Swift.String : Any] {
      get
      set
    }
    public var messageExtras: Swift.String?
    public var context: BrazeKit.Braze.InAppMessage.Context?
    public init(clickAction: BrazeKit.Braze.InAppMessage.ClickAction = .none, messageClose: BrazeKit.Braze.InAppMessage.MessageClose = .userInteraction, orientation: BrazeKit.Braze.InAppMessage.Orientation = .any, animateIn: Swift.Bool = true, animateOut: Swift.Bool = true, extras: [Swift.String : Any] = [:], messageExtras: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Data, b: BrazeKit.Braze.InAppMessage.Data) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@dynamicMemberLookup public protocol BrazeInAppMessageDataLookup {
  var data: BrazeKit.Braze.InAppMessage.Data { get set }
  subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.InAppMessage.Data, Value>) -> Value { get set }
}
extension BrazeKit.BrazeInAppMessageDataLookup {
  public subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.InAppMessage.Data, Value>) -> Value {
    get
    set
  }
}
extension BrazeKit.Braze.InAppMessage {
  public var data: BrazeKit.Braze.InAppMessage.Data {
    get
    set
  }
  public var multipleLogClickEnabled: Swift.Bool {
    get
  }
}
extension BrazeKit.Braze.InAppMessage {
  public func json() -> Foundation.Data?
  public static func decoding(json: Foundation.Data) -> BrazeKit.Braze.InAppMessage?
}
extension BrazeKit.Braze.InAppMessage {
  public func logImpression(using braze: BrazeKit.Braze)
  public func logClick(buttonId: Swift.String?, using braze: BrazeKit.Braze)
  public func getLocalAssets(using braze: BrazeKit.Braze, urls: [Foundation.URL], destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<[Foundation.URL : Foundation.URL], any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
  public func withLocalAssets(using braze: BrazeKit.Braze, destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<BrazeKit.Braze.InAppMessage, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze.InAppMessage {
  public func isApproximatelyEqual(to message: BrazeKit.Braze.InAppMessage) -> Swift.Bool
}
extension BrazeKit.Braze.InAppMessageRaw {
  @available(swift, obsoleted: 0.0.1)
  @objc(_compat_hideChevron) final public var _compat_hideChevron: Swift.Bool {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(_compat_overrideUserInterfaceStyle) final public var _compat_overrideUserInterfaceStyle: Swift.Int {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @available(swift, obsoleted: 0.0.1)
  @objc(type) final public var _objc_type: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(clickAction) final public var _objc_clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(messageClose) final public var _objc_messageClose: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(orientation) final public var _objc_orientation: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(messageTextAlignment) final public var _objc_messageTextAlignment: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(headerTextAlignment) final public var _objc_headerTextAlignment: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(duration) final public var _objc_duration: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(imageStyle) final public var _objc_imageStyle: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(slideFrom) final public var _objc_slideFrom: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.InAppMessageRaw.Button {
  @available(swift, obsoleted: 0.0.1)
  @objc(clickAction) final public var _objc_clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc convenience dynamic public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc convenience dynamic public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool, textColor: BrazeKit.Braze.InAppMessageRaw.Color, backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color, borderColor: BrazeKit.Braze.InAppMessageRaw.Color)
}
extension BrazeKit.Braze.InAppMessageRaw {
  @objc final public func logImpression(using braze: BrazeKit.Braze)
  @objc final public func logClick(buttonId: Swift.String?, using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.InAppMessageRaw {
  @objc(BRZInAppMessageRawType) public enum _OBJC_BRZInAppMessageRawType : Swift.Int, Swift.Sendable {
    case slideup
    case modal
    case full
    case htmlFull
    case html
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawClickAction) public enum _OBJC_BRZInAppMessageRawClickAction : Swift.Int, Swift.Sendable {
    case none
    @objc(BRZInAppMessageRawClickActionURL) case url
    public init(_ clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction)
    public var clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawClose) public enum _OBJC_BRZInAppMessageRawClose : Swift.Int, Swift.Sendable {
    case autoDismiss
    case swipe
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawOrientation) public enum _OBJC_BRZInAppMessageRawOrientation : Swift.Int, Swift.Sendable {
    case any
    case portrait
    case landscape
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawTextAlignment) public enum _OBJC_BRZInAppMessageRawTextAlignment : Swift.Int, Swift.Sendable {
    case start
    case center
    case end
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawImageStyle) public enum _OBJC_BRZInAppMessageRawImageStyle : Swift.Int, Swift.Sendable {
    case graphic
    case top
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawSlideFrom) public enum _OBJC_BRZInAppMessageRawSlideFrom : Swift.Int, Swift.Sendable {
    case top
    case bottom
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZInAppMessageRaw) final public class InAppMessageRaw : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    final public var id: Swift.String? {
      get
      set
    }
    final public var type: BrazeKit.Braze.InAppMessageRaw.MessageType {
      get
      set
    }
    final public var clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction {
      get
      set
    }
    @objc final public var url: Foundation.URL? {
      @objc get
      @objc set
    }
    @objc final public var useWebView: Swift.Bool {
      @objc get
      @objc set
    }
    final public var messageClose: BrazeKit.Braze.InAppMessageRaw.MessageClose {
      get
      set
    }
    final public var orientation: BrazeKit.Braze.InAppMessageRaw.Orientation {
      get
      set
    }
    @objc final public var message: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var header: Swift.String? {
      @objc get
      @objc set
    }
    final public var messageTextAlignment: BrazeKit.Braze.InAppMessageRaw.TextAlignment? {
      get
      set
    }
    final public var headerTextAlignment: BrazeKit.Braze.InAppMessageRaw.TextAlignment? {
      get
      set
    }
    @objc final public var imageURL: Foundation.URL? {
      @objc get
      @objc set
    }
    @objc final public var imageAltText: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var language: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var icon: Swift.String? {
      @objc get
      @objc set
    }
    final public var duration: Foundation.TimeInterval? {
      get
      set
    }
    @objc final public var themes: [Swift.String : BrazeKit.Braze.InAppMessageRaw.Theme]? {
      @objc get
      @objc set
    }
    @objc final public var textColor: BrazeKit.Braze.InAppMessageRaw.Color? {
      @objc get
      @objc set
    }
    @objc final public var headerTextColor: BrazeKit.Braze.InAppMessageRaw.Color? {
      @objc get
      @objc set
    }
    @objc final public var iconColor: BrazeKit.Braze.InAppMessageRaw.Color? {
      @objc get
      @objc set
    }
    @objc final public var iconBackgroundColor: BrazeKit.Braze.InAppMessageRaw.Color? {
      @objc get
      @objc set
    }
    @objc final public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color? {
      @objc get
      @objc set
    }
    @objc final public var frameColor: BrazeKit.Braze.InAppMessageRaw.Color? {
      @objc get
      @objc set
    }
    @objc final public var closeButtonColor: BrazeKit.Braze.InAppMessageRaw.Color? {
      @objc get
      @objc set
    }
    @objc final public var buttons: [BrazeKit.Braze.InAppMessageRaw.Button]? {
      @objc get
      @objc set
    }
    final public var imageStyle: BrazeKit.Braze.InAppMessageRaw.ImageStyle? {
      get
      set
    }
    final public var slideFrom: BrazeKit.Braze.InAppMessageRaw.SlideFrom? {
      get
      set
    }
    @objc final public var animateIn: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var animateOut: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var extras: [Swift.String : Any] {
      @objc get
      @objc set
    }
    @objc final public var messageExtras: Swift.String? {
      @objc get
      @objc set
    }
    @objc final public var baseURL: Foundation.URL? {
      @objc get
      @objc set
    }
    @objc final public var assetURLs: [Foundation.URL]? {
      @objc get
      @objc set
    }
    @objc final public var isControl: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var isTestSend: Swift.Bool {
      @objc get
    }
    @objc final public var messageFields: [Swift.String : Any]? {
      @objc get
      @objc set
    }
    @objc final public var context: BrazeKit.Braze.InAppMessageRaw.Context? {
      @objc get
      @objc set
    }
    @objc final public func json() -> Foundation.Data?
    @objc public static func decoding(json: Foundation.Data) -> Self?
    @objc override dynamic public init()
    public init(_ message: BrazeKit.Braze.InAppMessage)
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    @objc deinit
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawButton) final public class Button : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    @objc(identifier) final public var id: Swift.Int {
      @objc get
      @objc set
    }
    @objc final public var text: Swift.String {
      @objc get
      @objc set
    }
    final public var clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction {
      get
      set
    }
    @objc final public var url: Foundation.URL? {
      @objc get
      @objc set
    }
    @objc final public var useWebView: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var textColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var borderColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction, url: Foundation.URL?, useWebView: Swift.Bool, textColor: BrazeKit.Braze.InAppMessageRaw.Color = ButtonTheme.defaultLight.textColor, backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color = ButtonTheme.defaultLight.backgroundColor, borderColor: BrazeKit.Braze.InAppMessageRaw.Color = ButtonTheme.defaultLight.borderColor)
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawTheme) final public class Theme : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    @objc public static var defaultLight: BrazeKit.Braze.InAppMessageRaw.Theme {
      @objc get
    }
    @objc public static var defaultDark: BrazeKit.Braze.InAppMessageRaw.Theme {
      @objc get
    }
    @objc final public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var textColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var iconColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var iconBackgroundColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var headerTextColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var closeButtonColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var frameColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var buttons: [BrazeKit.Braze.InAppMessageRaw.ButtonTheme] {
      @objc get
      @objc set
    }
    @objc convenience override dynamic public init()
    public init(backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color, textColor: BrazeKit.Braze.InAppMessageRaw.Color, iconColor: BrazeKit.Braze.InAppMessageRaw.Color, iconBackgroundColor: BrazeKit.Braze.InAppMessageRaw.Color, headerTextColor: BrazeKit.Braze.InAppMessageRaw.Color, closeButtonColor: BrazeKit.Braze.InAppMessageRaw.Color, frameColor: BrazeKit.Braze.InAppMessageRaw.Color, buttons: [BrazeKit.Braze.InAppMessageRaw.ButtonTheme])
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawButtonTheme) final public class ButtonTheme : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    @objc public static var defaultLight: BrazeKit.Braze.InAppMessageRaw.ButtonTheme {
      @objc get
    }
    @objc public static var defaultDark: BrazeKit.Braze.InAppMessageRaw.ButtonTheme {
      @objc get
    }
    @objc final public var textColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var borderColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc final public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color {
      @objc get
      @objc set
    }
    @objc convenience override dynamic public init()
    public init(textColor: BrazeKit.Braze.InAppMessageRaw.Color, borderColor: BrazeKit.Braze.InAppMessageRaw.Color, backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color)
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    final public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawColor) final public class Color : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    @objc override dynamic public init()
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    @objc deinit
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  public enum MessageType : Swift.String, Swift.Codable, Swift.Sendable {
    case slideup
    case modal
    case full
    case htmlFull
    case html
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ClickAction : Swift.String, Swift.Codable, Swift.Sendable {
    case none
    case url
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum MessageClose : Swift.String, Swift.Codable, Swift.Sendable {
    case autoDismiss
    case swipe
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Orientation : Swift.String, Swift.Codable, Swift.Sendable {
    case any
    case portrait
    case landscape
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TextAlignment : Swift.String, Swift.Codable, Swift.Sendable {
    case start
    case center
    case end
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ImageStyle : Swift.String, Swift.Codable, Swift.Sendable {
    case graphic
    case top
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SlideFrom : Swift.String, Swift.Codable, Swift.Sendable {
    case top
    case bottom
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.InAppMessage {
  public init(_ message: BrazeKit.Braze.InAppMessageRaw) throws
}
extension BrazeKit.Braze.InAppMessage {
  public struct Theme : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var backgroundColor: BrazeKit.Braze.InAppMessage.Color
    public var textColor: BrazeKit.Braze.InAppMessage.Color
    public var iconColor: BrazeKit.Braze.InAppMessage.Color
    public var iconBackgroundColor: BrazeKit.Braze.InAppMessage.Color
    public var headerTextColor: BrazeKit.Braze.InAppMessage.Color
    public var closeButtonColor: BrazeKit.Braze.InAppMessage.Color
    public var frameColor: BrazeKit.Braze.InAppMessage.Color
    public init(backgroundColor: BrazeKit.Braze.InAppMessage.Color = .clear, textColor: BrazeKit.Braze.InAppMessage.Color = .clear, iconColor: BrazeKit.Braze.InAppMessage.Color = .clear, iconBackgroundColor: BrazeKit.Braze.InAppMessage.Color = .clear, headerTextColor: BrazeKit.Braze.InAppMessage.Color = .clear, closeButtonColor: BrazeKit.Braze.InAppMessage.Color = .clear, frameColor: BrazeKit.Braze.InAppMessage.Color = .clear)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Theme, b: BrazeKit.Braze.InAppMessage.Theme) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Themes : Swift.Hashable, Swift.Codable, Swift.ExpressibleByDictionaryLiteral, Swift.Sendable {
    public var light: BrazeKit.Braze.InAppMessage.Theme {
      get
      set
    }
    public var dark: BrazeKit.Braze.InAppMessage.Theme? {
      get
      set
    }
    public var themes: [Swift.String : BrazeKit.Braze.InAppMessage.Theme]
    public subscript(name: Swift.String) -> BrazeKit.Braze.InAppMessage.Theme? {
      get
      set
    }
    public init(themes: [Swift.String : BrazeKit.Braze.InAppMessage.Theme])
    public init(dictionaryLiteral elements: (Swift.String, BrazeKit.Braze.InAppMessage.Theme)...)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Themes, b: BrazeKit.Braze.InAppMessage.Themes) -> Swift.Bool
    public typealias Key = Swift.String
    public typealias Value = BrazeKit.Braze.InAppMessage.Theme
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ButtonTheme : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var textColor: BrazeKit.Braze.InAppMessage.Color
    public var borderColor: BrazeKit.Braze.InAppMessage.Color
    public var backgroundColor: BrazeKit.Braze.InAppMessage.Color
    public init(textColor: BrazeKit.Braze.InAppMessage.Color = .clear, borderColor: BrazeKit.Braze.InAppMessage.Color = .clear, backgroundColor: BrazeKit.Braze.InAppMessage.Color = .clear)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ButtonTheme, b: BrazeKit.Braze.InAppMessage.ButtonTheme) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ButtonThemes : Swift.Hashable, Swift.Codable, Swift.ExpressibleByDictionaryLiteral, Swift.Sendable {
    public var light: BrazeKit.Braze.InAppMessage.ButtonTheme {
      get
    }
    public var dark: BrazeKit.Braze.InAppMessage.ButtonTheme? {
      get
    }
    public var themes: [Swift.String : BrazeKit.Braze.InAppMessage.ButtonTheme]
    public subscript(name: Swift.String) -> BrazeKit.Braze.InAppMessage.ButtonTheme? {
      get
    }
    public init(themes: [Swift.String : BrazeKit.Braze.InAppMessage.ButtonTheme])
    public init(dictionaryLiteral elements: (Swift.String, BrazeKit.Braze.InAppMessage.ButtonTheme)...)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ButtonThemes, b: BrazeKit.Braze.InAppMessage.ButtonThemes) -> Swift.Bool
    public typealias Key = Swift.String
    public typealias Value = BrazeKit.Braze.InAppMessage.ButtonTheme
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessage.Theme {
  public static let defaultLight: BrazeKit.Braze.InAppMessage.Theme
  public static let defaultDark: BrazeKit.Braze.InAppMessage.Theme
}
extension BrazeKit.Braze.InAppMessage.ButtonTheme {
  public static let primary: BrazeKit.Braze.InAppMessage.ButtonTheme
  public static let secondary: BrazeKit.Braze.InAppMessage.ButtonTheme
  public static let defaultLight: BrazeKit.Braze.InAppMessage.ButtonTheme
  public static let defaultDark: BrazeKit.Braze.InAppMessage.ButtonTheme
}
extension BrazeKit.Braze.InAppMessage.Themes {
  public static let defaults: BrazeKit.Braze.InAppMessage.Themes
}
extension BrazeKit.Braze.InAppMessage.ButtonThemes {
  public static let defaults: BrazeKit.Braze.InAppMessage.ButtonThemes
}
public protocol BrazeInAppMessageThemeable {
  var themes: BrazeKit.Braze.InAppMessage.Themes { get }
}
extension BrazeKit.Braze.InAppMessage {
  public struct Slideup : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var graphic: BrazeKit.Braze.InAppMessage.Graphic?
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var message: Swift.String
    public var slideFrom: BrazeKit.Braze.InAppMessage.SlideFrom
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), graphic: BrazeKit.Braze.InAppMessage.Graphic? = nil, imageAltText: Swift.String? = nil, language: Swift.String? = nil, message: Swift.String = "", slideFrom: BrazeKit.Braze.InAppMessage.SlideFrom = .bottom, themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Slideup, b: BrazeKit.Braze.InAppMessage.Slideup) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Modal : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var graphic: BrazeKit.Braze.InAppMessage.Graphic?
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var header: Swift.String
    public var headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var message: Swift.String
    public var messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), graphic: BrazeKit.Braze.InAppMessage.Graphic? = nil, imageAltText: Swift.String? = nil, language: Swift.String? = nil, header: Swift.String = "", headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, message: Swift.String = "", messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Modal, b: BrazeKit.Braze.InAppMessage.Modal) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ModalImage : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var imageURL: Foundation.URL
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), imageURL: Foundation.URL, imageAltText: Swift.String? = nil, language: Swift.String? = nil, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ModalImage, b: BrazeKit.Braze.InAppMessage.ModalImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Full : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var imageURL: Foundation.URL
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var header: Swift.String
    public var headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var message: Swift.String
    public var messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), imageURL: Foundation.URL, imageAltText: Swift.String? = nil, language: Swift.String? = nil, header: Swift.String = "", headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, message: Swift.String = "", messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Full, b: BrazeKit.Braze.InAppMessage.Full) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct FullImage : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var imageURL: Foundation.URL
    public var imageAltText: Swift.String?
    public var language: Swift.String?
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), imageURL: Foundation.URL, imageAltText: Swift.String? = nil, language: Swift.String? = nil, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.FullImage, b: BrazeKit.Braze.InAppMessage.FullImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Html : BrazeKit.BrazeInAppMessageDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var message: Swift.String
    public var baseURL: Foundation.URL?
    public var assetURLs: Swift.Set<Foundation.URL>
    public var legacy: Swift.Bool
    public var messageFields: [Swift.String : Any] {
      get
      set
    }
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), message: Swift.String = "<html></html>", baseURL: Foundation.URL? = nil, assetURLs: Swift.Set<Foundation.URL> = [], legacy: Swift.Bool = false, messageFields: [Swift.String : Any] = [:])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Html, b: BrazeKit.Braze.InAppMessage.Html) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Control : BrazeKit.BrazeInAppMessageDataLookup, Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init())
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Control, b: BrazeKit.Braze.InAppMessage.Control) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessage {
  public enum ClickAction : Swift.Hashable, Swift.Codable, Swift.Sendable {
    case none
    case url(Foundation.URL, useWebView: Swift.Bool)
    public var url: Foundation.URL? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ClickAction, b: BrazeKit.Braze.InAppMessage.ClickAction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum MessageClose : Swift.Hashable, Swift.Codable, Swift.Sendable {
    case userInteraction
    case auto(after: Foundation.TimeInterval)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.MessageClose, b: BrazeKit.Braze.InAppMessage.MessageClose) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum Orientation : Swift.String, Swift.Hashable, Swift.Codable, Swift.Sendable {
    case any
    case portrait
    case landscape
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TextAlignment : Swift.String, Swift.Hashable, Swift.Codable, Swift.Sendable {
    case leading
    case center
    case trailing
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Graphic : Swift.Hashable, Swift.Codable, Swift.Sendable {
    case icon(Swift.String)
    case image(Foundation.URL)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Graphic, b: BrazeKit.Braze.InAppMessage.Graphic) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Button : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public var id: Swift.Int
    public var text: Swift.String
    public var clickAction: BrazeKit.Braze.InAppMessage.ClickAction
    public var themes: BrazeKit.Braze.InAppMessage.ButtonThemes
    public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessage.ClickAction, themes: BrazeKit.Braze.InAppMessage.ButtonThemes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Button, b: BrazeKit.Braze.InAppMessage.Button) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Color : Swift.RawRepresentable, Swift.Hashable, Swift.Codable, Swift.ExpressibleByIntegerLiteral, Swift.Sendable {
    public var rawValue: Swift.UInt32
    public var r: Swift.Double {
      get
    }
    public var g: Swift.Double {
      get
    }
    public var b: Swift.Double {
      get
    }
    public var a: Swift.Double {
      get
    }
    public static let clear: BrazeKit.Braze.InAppMessage.Color
    public static let white: BrazeKit.Braze.InAppMessage.Color
    public static let black: BrazeKit.Braze.InAppMessage.Color
    public static let red: BrazeKit.Braze.InAppMessage.Color
    public static let green: BrazeKit.Braze.InAppMessage.Color
    public static let blue: BrazeKit.Braze.InAppMessage.Color
    public init(rawValue: Swift.UInt32)
    public init(red: Swift.Double, green: Swift.Double, blue: Swift.Double, alpha: Swift.Double)
    public init(integerLiteral value: Swift.UInt32)
    public typealias IntegerLiteralType = Swift.UInt32
    public typealias RawValue = Swift.UInt32
  }
  public enum SlideFrom : Swift.String, Swift.Hashable, Swift.Codable, Swift.Sendable {
    case top
    case bottom
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.InAppMessage.Color {
  public var uiColor: UIKit.UIColor {
    get
  }
  public init(_ color: UIKit.UIColor)
}
extension BrazeKit.Braze.InAppMessageRaw.Color {
  @objc final public var uiColor: UIKit.UIColor {
    @objc get
  }
  @objc convenience dynamic public init(_ color: UIKit.UIColor)
}
extension BrazeKit.Braze {
  @objc @_hasMissingDesignatedInitializers final public class LiveActivities : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc deinit
  }
}
extension BrazeKit.Braze.LiveActivities {
  public enum PushToStartTokenUpdate : Swift.Equatable {
    case tokenRead(BrazeKit.Braze.User.PushToStartToken)
    case tokenFlushed(BrazeKit.Braze.User.PushToStartToken)
    case optOutRequested(BrazeKit.Braze.User.PushToStartToken)
    case optOutFlushed(BrazeKit.Braze.User.PushToStartToken)
    public static func == (a: BrazeKit.Braze.LiveActivities.PushToStartTokenUpdate, b: BrazeKit.Braze.LiveActivities.PushToStartTokenUpdate) -> Swift.Bool
  }
}
@available(iOS 16.1, *)
@available(macOS, unavailable)
@available(macCatalyst, unavailable)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension BrazeKit.Braze.LiveActivities {
  final public var pushToStartTokenUpdatesStream: _Concurrency.AsyncStream<BrazeKit.Braze.LiveActivities.PushToStartTokenUpdate> {
    get
  }
  @discardableResult
  final public func launchActivity<BrazeActivityAttributes>(pushTokenTag: Swift.String, activity: ActivityKit.Activity<BrazeActivityAttributes>, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line) -> _Concurrency.Task<Swift.Void, Swift.Never>? where BrazeActivityAttributes : ActivityKit.ActivityAttributes
  final public func resumeActivities<BrazeActivityAttributes>(ofType type: ActivityKit.Activity<BrazeActivityAttributes>.Type) where BrazeActivityAttributes : ActivityKit.ActivityAttributes
  @available(iOS 17.2, *)
  final public func registerPushToStart<AttributesType>(forType type: ActivityKit.Activity<AttributesType>.Type, name: Swift.String) -> _Concurrency.Task<Swift.Void, Swift.Never> where AttributesType : ActivityKit.ActivityAttributes, AttributesType : BrazeKit.BrazeLiveActivityAttributes
  final public func optOutPushToStart(type: Swift.String)
}
extension BrazeKit.Braze {
  @objc(BRZModalContext) final public class ModalContext : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc final public var presentingViewController: UIKit.UIViewController {
      @objc get
      @objc set
    }
    @objc final public var animatePresentation: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var animateDismissal: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var openNewWindowLinksInBrowser: Swift.Bool {
      @objc get
      @objc set
    }
    final public let channel: BrazeKit.Braze.Channel
    public init(presentingViewController: UIKit.UIViewController, animatePresentation: Swift.Bool = true, animateDismissal: Swift.Bool = true, openNewWindowLinksInBrowser: Swift.Bool = false, channel: BrazeKit.Braze.Channel)
    @objc deinit
  }
}
extension BrazeKit.Braze.Notifications {
  @available(swift, obsoleted: 0.0.1)
  @objc(registerDeviceToken:) final public func _objc_register(deviceToken: Foundation.Data)
  @objc(subscribeToUpdatesWithPayloadTypes:update:) final public func _objc_subscribeToUpdates(payloadTypes: BrazeKit.Braze.Notifications.Payload.PayloadTypeFilter, _ update: @escaping (BrazeKit.Braze.Notifications.Payload) -> Swift.Void) -> BrazeKit.Braze.Cancellable
  @objc(subscribeToUpdates:) final public func _objc_subscribeToUpdates(_ update: @escaping (BrazeKit.Braze.Notifications.Payload) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZNotifications) final public class Notifications : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public var notificationsStream: _Concurrency.AsyncStream<BrazeKit.Braze.Notifications.Payload> {
      get
    }
    @objc final public var deviceToken: Foundation.Data? {
      @objc get
    }
    final public func register(deviceToken: Foundation.Data, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    @objc final public func handleBackgroundNotification(userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void) -> Swift.Bool
    @objc final public func handleForegroundNotification(notification: UserNotifications.UNNotification)
    @objc final public func handleUserNotification(response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void) -> Swift.Bool
    final public func subscribeToUpdates(payloadTypes: BrazeKit.Braze.Notifications.Payload.PayloadTypeFilter = [.opened, .received], _ update: @escaping (BrazeKit.Braze.Notifications.Payload) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc public static func isBrazeNotification(_ userInfo: [Swift.AnyHashable : Any]) -> Swift.Bool
    @objc public static func isInternalNotification(_ userInfo: [Swift.AnyHashable : Any]) -> Swift.Bool
    @objc deinit
  }
}
extension BrazeKit.Braze.Notifications {
  @objc public static var categories: Swift.Set<UserNotifications.UNNotificationCategory> {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.Notifications.Payload {
  @available(swift, obsoleted: 0.0.1)
  @objc convenience dynamic public init?(userInfo: [Swift.AnyHashable : Any], type: BrazeKit.Braze.Notifications.Payload._OBJC_PayloadType = .opened, silent: Swift.Bool = false)
  @objc(BRZNotificationsPayloadType) public enum _OBJC_PayloadType : Swift.Int, Swift.Sendable {
    case received
    case opened
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(type) final public var _objc_type: BrazeKit.Braze.Notifications.Payload._OBJC_PayloadType {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(badge) final public var _objc_badge: Foundation.NSNumber? {
    @objc get
  }
}
extension BrazeKit.Braze.Notifications.Payload {
  public enum PayloadType : Swift.String, Swift.Codable, Swift.Sendable {
    case received
    case opened
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc(BRZNotificationsPayloadTypeFilter) final public class PayloadTypeFilter : ObjectiveC.NSObject, Swift.Encodable, Swift.OptionSet, Swift.Sendable {
    @objc final public let rawValue: Swift.Int
    @objc public static let received: BrazeKit.Braze.Notifications.Payload.PayloadTypeFilter
    @objc public static let opened: BrazeKit.Braze.Notifications.Payload.PayloadTypeFilter
    @objc public init(rawValue: Swift.Int)
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    public typealias ArrayLiteralElement = BrazeKit.Braze.Notifications.Payload.PayloadTypeFilter
    public typealias Element = BrazeKit.Braze.Notifications.Payload.PayloadTypeFilter
    public typealias RawValue = Swift.Int
    @objc deinit
  }
}
extension BrazeKit.Braze.Notifications {
  @_hasMissingDesignatedInitializers @objc(BRZNotificationsPayload) final public class Payload : ObjectiveC.NSObject, Swift.Encodable, Swift.Sendable {
    final public var type: BrazeKit.Braze.Notifications.Payload.PayloadType {
      get
    }
    @objc final public var title: Swift.String? {
      @objc get
    }
    @objc final public var subtitle: Swift.String? {
      @objc get
    }
    @objc final public var body: Swift.String? {
      @objc get
    }
    final public var badge: Swift.Int? {
      get
    }
    @objc final public var date: Foundation.Date {
      @objc get
    }
    @objc final public var urlContext: BrazeKit.Braze.URLContext? {
      @objc get
    }
    @objc final public var actionIdentifier: Swift.String {
      @objc get
    }
    @objc final public var isSilent: Swift.Bool {
      @objc get
    }
    @objc final public var isInternal: Swift.Bool {
      @objc get
    }
    @available(iOS 13.0, *)
    @objc final public var targetScene: UIKit.UIScene? {
      @objc get
    }
    @objc final public var userInfo: [Swift.String : Any] {
      @objc get
    }
    convenience public init?(userInfo: [Swift.AnyHashable : Any], type: BrazeKit.Braze.Notifications.Payload.PayloadType = .opened, silent: Swift.Bool = false)
    final public func encode(to encoder: any Swift.Encoder) throws
    @objc final public func json() -> Foundation.Data?
    @objc final public func userInfoJSON() -> Foundation.Data?
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
  }
}
public var overrideResourcesBundle: Foundation.Bundle? {
  get
  set
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZResources) final public class Resources : ObjectiveC.NSObject {
    @objc public static let bundle: Foundation.Bundle?
    @objc public static let acknowledgments: [Swift.String : Foundation.URL]
    @objc public static let license: Foundation.URL?
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZSDKAuthenticationError) final public class SDKAuthenticationError : ObjectiveC.NSObject, Swift.Error, Swift.Sendable {
    @objc final public let code: Swift.Int
    @objc final public let reason: Swift.String?
    @objc final public let userId: Swift.String?
    @objc final public let signature: Swift.String?
    @objc final public let optional: Swift.Bool
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers @objc(BRZSessionEvent) final public class _OBJC_BrazeSessionEvent : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public let sessionId: Foundation.UUID
  @objc final public let state: BrazeKit._OBJC_BrazeSessionState
  @objc deinit
}
@objc(BRZSessionState) public enum _OBJC_BrazeSessionState : Swift.Int, Swift.Sendable {
  case started
  case ended
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension BrazeKit.Braze {
  public enum SessionEvent : Swift.Equatable, Swift.Sendable {
    case started(Foundation.UUID)
    case ended(Foundation.UUID)
    public static func == (a: BrazeKit.Braze.SessionEvent, b: BrazeKit.Braze.SessionEvent) -> Swift.Bool
  }
}
extension BrazeKit.Braze {
  @objc(subscribeToSessionUpdates:) final public func _objc_subscribeToSessionUpdates(_ update: @escaping @_Concurrency.MainActor (BrazeKit._OBJC_BrazeSessionEvent) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
  final public var sessionUpdatesStream: _Concurrency.AsyncStream<BrazeKit.Braze.SessionEvent> {
    get
  }
  final public func subscribeToSessionUpdates(_ update: @escaping @_Concurrency.MainActor (BrazeKit.Braze.SessionEvent) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze {
  public enum UIUtils {
  }
}
extension BrazeKit.Braze.UIUtils {
  @available(iOS 13.0, tvOS 13.0, *)
  public static var activeWindowScene: UIKit.UIWindowScene? {
    get
  }
  @available(iOS 13.0, tvOS 13.0, *)
  public static var preferredWindowScene: UIKit.UIWindowScene? {
    get
  }
  public static var activeWindow: UIKit.UIWindow? {
    get
  }
  public static var activeRootViewController: UIKit.UIViewController? {
    get
  }
  public static var activeTopmostViewController: UIKit.UIViewController? {
    get
  }
  public static var interfaceOrientation: UIKit.UIInterfaceOrientation {
    get
  }
  public static func preferredFont(textStyle: UIKit.UIFont.TextStyle, weight: UIKit.UIFont.Weight) -> UIKit.UIFont
}
extension BrazeKit.Braze {
  @objc(BRZURLContext) final public class URLContext : ObjectiveC.NSObject, Swift.Codable, @unchecked Swift.Sendable {
    @objc final public var url: Foundation.URL {
      @objc get
      @objc set
    }
    @objc final public var useWebView: Swift.Bool {
      @objc get
      @objc set
    }
    @objc final public var isUniversalLink: Swift.Bool {
      @objc get
      @objc set
    }
    final public let channel: BrazeKit.Braze.Channel
    @objc final public var extras: [Swift.String : Any] {
      @objc get
    }
    @available(iOS 13.0, tvOS 13.0, *)
    @objc final public var targetScene: UIKit.UIScene? {
      @objc get
      @objc set
    }
    @objc final public var targetViewController: UIKit.UIViewController? {
      @objc get
      @objc set
    }
    public init(url: Foundation.URL, useWebView: Swift.Bool, isUniversalLink: Swift.Bool = false, channel: BrazeKit.Braze.Channel, extras: [Swift.String : Any])
    required public init(from decoder: any Swift.Decoder) throws
    final public func encode(to encoder: any Swift.Encoder) throws
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
  }
}
@objc extension BrazeKit.Braze.User {
  @objc @available(*, deprecated, renamed: "set(firstName:)")
  final public var firstName: Swift.String? {
    @objc get
    @objc(_compat_setFirstName:) set
  }
  @objc @available(*, deprecated, renamed: "set(lastName:)")
  final public var lastName: Swift.String? {
    @objc get
    @objc(_compat_setLastName:) set
  }
  @objc @available(*, deprecated, renamed: "set(email:)")
  final public var email: Swift.String? {
    @objc get
    @objc(_compat_setEmail:) set
  }
  @objc @available(*, deprecated, renamed: "set(dateOfBirth:)")
  final public var dateOfBirth: Foundation.Date? {
    @objc get
    @objc(_compat_setDateOfBirth:) set
  }
  @objc @available(*, deprecated, renamed: "set(country:)")
  final public var country: Swift.String? {
    @objc get
    @objc(_compat_setCountry:) set
  }
  @objc @available(*, deprecated, renamed: "set(homeCity:)")
  final public var homeCity: Swift.String? {
    @objc get
    @objc(_compat_setHomeCity:) set
  }
  @objc @available(*, deprecated, renamed: "set(language:)")
  final public var language: Swift.String? {
    @objc get
    @objc(_compat_setLanguage:) set
  }
  @objc @available(*, deprecated, renamed: "set(phoneNumber:)")
  final public var phone: Swift.String? {
    @objc get
    @objc(_compat_setPhone:) set
  }
  @available(*, deprecated, renamed: "id")
  @objc final public var userID: Swift.String? {
    @objc get
  }
  @available(*, deprecated, message: "avatarImageURL is not supported by Braze anymore")
  @objc final public var avatarImageURL: Swift.String? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "facebookUser is not supported by Braze anymore")
  @objc final public var facebookUser: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "twitterUser is not supported by Braze anymore")
  @objc final public var twitterUser: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @objc @available(*, deprecated, renamed: "set(attributionData:)")
  final public var attributionData: Swift.AnyObject? {
    @objc get
    @objc(_compat_setAttributionData:) set
  }
  @available(*, deprecated, renamed: "add(alias:label:)")
  @objc final public func addAlias(_ alias: Swift.String, withLabel label: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "set(gender:)")
  @nonobjc final public func setGender<T>(_ gender: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue == Swift.Int
  @available(*, deprecated, renamed: "set(gender:)")
  @nonobjc final public func setGender(_ gender: BrazeKit.Braze.User.Gender) -> Swift.Bool
  @available(*, deprecated, renamed: "set(emailSubscriptionState:)")
  @nonobjc final public func setEmailNotificationSubscriptionType<T>(_ emailNotificationSubscriptionType: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue == Swift.Int
  @available(*, deprecated, renamed: "set(emailSubscriptionState:)")
  @objc final public func setEmailNotificationSubscriptionType(_ emailNotificationSubscriptionType: Swift.Int) -> Swift.Bool
  @available(*, deprecated, renamed: "set(pushNotificationSubscriptionState:)")
  @nonobjc final public func setPush<T>(_ pushNotificationSubscriptionType: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue == Swift.Int
  @available(*, deprecated, renamed: "set(pushNotificationSubscriptionState:)")
  @objc(setPushNotificationSubscriptionType:) final public func setPush(_ pushNotificationSubscriptionType: Swift.Int) -> Swift.Bool
  @available(*, deprecated, renamed: "addToSubscriptionGroup(id:)")
  @nonobjc final public func addToSubscriptionGroup(withGroupId groupId: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "removeFromSubscriptionGroup(id:)")
  @nonobjc final public func removeFromSubscriptionGroup(withGroupId groupId: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andBOOLValue value: Swift.Bool) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andIntegerValue value: Swift.Int) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andDoubleValue value: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andStringValue value: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andDateValue value: Foundation.Date) -> Swift.Bool
  @available(*, deprecated, renamed: "unsetCustomAttribute(key:)")
  @nonobjc final public func unsetCustomAttribute(withKey key: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "incrementCustomUserAttribute(key:by:)")
  @nonobjc final public func incrementCustomUserAttribute(_ key: Swift.String, by amount: Swift.Int = 1) -> Swift.Bool
  @available(*, deprecated, renamed: "addToCustomAttributeStringArray(key:value:)")
  @nonobjc final public func addToCustomAttributeArray(withKey key: Swift.String, value: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "removeFromCustomAttributeStringArray(key:value:)")
  @nonobjc final public func removeFromCustomAttributeArray(withKey key: Swift.String, value: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttributeArray(key:array:)")
  @nonobjc final public func setCustomAttributeArrayWithKey(_ key: Swift.String, array: [Swift.String]?) -> Swift.Bool
  @available(*, deprecated, renamed: "setLastKnownLocation(latitude:longitude:altitude:horizontalAccuracy:verticalAccuracy:)")
  @nonobjc final public func setLastKnownLocationWithLatitude(_ latitude: Swift.Double, longitude: Swift.Double, horizontalAccuracy: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "setLastKnownLocation(latitude:longitude:altitude:horizontalAccuracy:verticalAccuracy:)")
  @objc final public func setLastKnownLocationWithLatitude(_ latitude: Swift.Double, longitude: Swift.Double, horizontalAccuracy: Swift.Double, altitude: Swift.Double, verticalAccuracy: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "setLocationCustomAttribute(key:latitude:longitude:)")
  @objc final public func addLocationCustomAttribute(withKey key: Swift.String, latitude: Swift.Double, longitude: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "unsetLocationCustomAttribute(key:)")
  @objc final public func removeLocationCustomAttribute(withKey key: Swift.String) -> Swift.Bool
}
extension BrazeKit.Braze.User {
  @available(swift, obsoleted: 0.0.1)
  @objc(setEmail:) final public func _objc_set(email: Swift.String?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLanguage:) final public func _objc_set(language: Swift.String?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setGender:) final public func _objc_set(gender: BrazeKit._OBJC_BRZUserGender?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setEmailSubscriptionState:) final public func _objc_set(emailSubscriptionState: BrazeKit._OBJC_BRZUserSubscriptionState)
  @available(swift, obsoleted: 0.0.1)
  @objc(setPushNotificationSubscriptionState:) final public func _objc_set(pushNotificationSubscriptionState: BrazeKit._OBJC_BRZUserSubscriptionState)
  @available(swift, obsoleted: 0.0.1)
  @objc(setAttributionData:) final public func _objc_set(attributionData: BrazeKit._OBJC_BRZUserAttributionData?)
  @available(swift, obsoleted: 0.0.1)
  @objc(addAlias:label:) final public func _objc_add(alias: Swift.String, label: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:boolValue:) final public func _objc_setCustomAttribute(key: Swift.String, boolValue: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:doubleValue:) final public func _objc_setDoubleCustomAttribute(key: Swift.String, doubleValue: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:intValue:) final public func _objc_setIntCustomAttribute(key: Swift.String, intValue: Swift.Int)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:stringValue:) final public func _objc_setStringCustomAttribute(key: Swift.String, stringValue: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:dateValue:) final public func _objc_setDateCustomAttribute(key: Swift.String, dateValue: Foundation.Date)
  @available(swift, obsoleted: 0.0.1)
  @objc(unsetCustomAttributeWithKey:) final public func _objc_unsetCustomAttribute(key: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(incrementCustomUserAttribute:) final public func _objc_incrementCustomUserAttribute(key: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(incrementCustomUserAttribute:by:) final public func _objc_incrementCustomUserAttribute(key: Swift.String, by amount: Swift.Int)
  @available(swift, obsoleted: 0.0.1)
  @objc(addToCustomAttributeStringArrayWithKey:value:) final public func _objc_addToCustomAttributeStringArray(key: Swift.String, value: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(removeFromCustomAttributeStringArrayWithKey:value:) final public func _objc_removeFromCustomAttributeStringArray(key: Swift.String, value: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeArrayWithKey:array:) final public func _objc_setCustomAttributeArray(key: Swift.String, array: [Swift.String]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setNestedCustomAttributeArrayWithKey:value:) final public func _objc_setNestedCustomAttributeArray(key: Swift.String, array: [[Swift.String : Any]]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setNestedCustomAttributeDictionaryWithKey:value:) final public func _objc_setNestedCustomAttributeDictionary(key: Swift.String, dictionary: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setNestedCustomAttributeDictionaryWithKey:value:merge:) final public func _objc_setNestedCustomAttributeDictionary(key: Swift.String, dictionary: [Swift.String : Any]?, merge: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLastKnownLocationWithLatitude:longitude:horizontalAccuracy:) final public func _objc_setLastKnownLocation(latitude: Swift.Double, longitude: Swift.Double, horizontalAccuracy: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLastKnownLocationWithLatitude:longitude:altitude:horizontalAccuracy:verticalAccuracy:) final public func _objc_setLastKnownLocation(latitude: Swift.Double, longitude: Swift.Double, altitude: Swift.Double, horizontalAccuracy: Swift.Double, verticalAccuracy: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLocationCustomAttributeWithKey:latitude:longitude:) final public func _objc_setLocationCustomAttribute(key: Swift.String, latitude: Swift.Double, longitude: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(unsetLocationCustomAttributeWithKey:) final public func _objc_unsetLocationCustomAttribute(key: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(addToSubscriptionGroupWithGroupId:) final public func _objc_addToSubscriptionGroup(id: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(removeFromSubscriptionGroupWithGroupId:) final public func _objc_removeFromSubscriptionGroup(id: Swift.String)
}
@_hasMissingDesignatedInitializers @objc(BRZUserGender) final public class _OBJC_BRZUserGender : ObjectiveC.NSObject, Swift.Sendable {
  @objc public static let male: BrazeKit._OBJC_BRZUserGender
  @objc public static let female: BrazeKit._OBJC_BRZUserGender
  @objc public static let other: BrazeKit._OBJC_BRZUserGender
  @objc public static let unknown: BrazeKit._OBJC_BRZUserGender
  @objc public static let notApplicable: BrazeKit._OBJC_BRZUserGender
  @objc public static let preferNotToSay: BrazeKit._OBJC_BRZUserGender
  @objc deinit
}
@objc(BRZUserSubscriptionState) public enum _OBJC_BRZUserSubscriptionState : Swift.Int, Swift.Sendable {
  case optedIn
  case subscribed
  case unsubscribed
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(BRZUserAttributionData) final public class _OBJC_BRZUserAttributionData : ObjectiveC.NSObject, Swift.Sendable {
  @objc final public var network: Swift.String? {
    @objc get
  }
  @objc final public var campaign: Swift.String? {
    @objc get
  }
  @objc final public var adGroup: Swift.String? {
    @objc get
  }
  @objc final public var creative: Swift.String? {
    @objc get
  }
  @objc public init(network: Swift.String?, campaign: Swift.String?, adGroup: Swift.String?, creative: Swift.String?)
  @objc deinit
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZUser) final public class User : ObjectiveC.NSObject, @unchecked Swift.Sendable {
    @objc(identifier) final public var id: Swift.String? {
      @objc get
    }
    @objc(setFirstName:) final public func set(firstName: Swift.String?)
    @objc(setLastName:) final public func set(lastName: Swift.String?)
    final public func set(email: Swift.String?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    @objc(setDateOfBirth:) final public func set(dateOfBirth: Foundation.Date?)
    @objc(setCountry:) final public func set(country: Swift.String?)
    @objc(setHomeCity:) final public func set(homeCity: Swift.String?)
    final public func set(language: Swift.String?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func set(gender: BrazeKit.Braze.User.Gender?)
    @objc(setPhoneNumber:) final public func set(phoneNumber: Swift.String?)
    final public func set(emailSubscriptionState: BrazeKit.Braze.User.SubscriptionState)
    final public func set(pushNotificationSubscriptionState: BrazeKit.Braze.User.SubscriptionState)
    final public func set(attributionData: BrazeKit.Braze.User.AttributionData?)
    final public func add(alias: Swift.String, label: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.Bool, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.Double, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.Int, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Foundation.Date, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func unsetCustomAttribute(key: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func incrementCustomUserAttribute(key: Swift.String, by amount: Swift.Int = 1, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func addToCustomAttributeStringArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func removeFromCustomAttributeStringArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, array: [Swift.String]?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, array: [[Swift.String : Any?]], fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, dictionary: [Swift.String : Any?], merge: Swift.Bool = false, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setLastKnownLocation(latitude: Swift.Double, longitude: Swift.Double, altitude: Swift.Double? = nil, horizontalAccuracy: Swift.Double? = nil, verticalAccuracy: Swift.Double? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setLocationCustomAttribute(key: Swift.String, latitude: Swift.Double, longitude: Swift.Double, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func unsetLocationCustomAttribute(key: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func addToSubscriptionGroup(id: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func removeFromSubscriptionGroup(id: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    @objc deinit
  }
}
extension BrazeKit.Braze.User {
  public struct AttributionData : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public let network: Swift.String?
    public let campaign: Swift.String?
    public let adGroup: Swift.String?
    public let creative: Swift.String?
    public init(network: Swift.String? = nil, campaign: Swift.String? = nil, adGroup: Swift.String? = nil, creative: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.User.AttributionData, b: BrazeKit.Braze.User.AttributionData) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.User {
  public enum Gender : Swift.String, Swift.Codable, Swift.CaseIterable, Swift.Sendable {
    case male
    case female
    case other
    case unknown
    case notApplicable
    case preferNotToSay
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.User.Gender]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [BrazeKit.Braze.User.Gender] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.User {
  public struct PushToStartToken : Swift.Hashable, Swift.Codable, Swift.Sendable {
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.User.PushToStartToken, b: BrazeKit.Braze.User.PushToStartToken) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.User {
  public enum SubscriptionGroupStatus : Swift.String, Swift.Codable, Swift.CaseIterable, Swift.Sendable {
    case subscribed
    case unsubscribed
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.User.SubscriptionGroupStatus]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [BrazeKit.Braze.User.SubscriptionGroupStatus] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.User {
  public enum SubscriptionState : Swift.String, Swift.Codable, Swift.CaseIterable, Swift.Sendable {
    case optedIn
    case subscribed
    case unsubscribed
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.User.SubscriptionState]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [BrazeKit.Braze.User.SubscriptionState] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze {
  public enum WebViewBridge {
  }
}
extension BrazeKit.Braze.WebViewBridge {
  public struct QueryHandler {
    public init(logClick: @escaping (Swift.String?) -> Swift.Void, logError: @escaping (BrazeKit.Braze.WebViewBridge.QueryHandler.Error) -> Swift.Void)
    public enum Error : Swift.Error, Swift.Hashable {
      case invalidButtonId(Swift.String?)
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: BrazeKit.Braze.WebViewBridge.QueryHandler.Error, b: BrazeKit.Braze.WebViewBridge.QueryHandler.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public func processInAppMessageURL(_ url: Foundation.URL, logBodyClick: Swift.Bool = true) -> (BrazeKit.Braze.InAppMessage.ClickAction, Swift.String?)
    public func processBannerURL(_ url: Foundation.URL) -> BrazeKit.Braze.Banner.ClickAction
  }
}
extension BrazeKit.Braze.WebViewBridge {
  @objc final public class SchemeHandler : ObjectiveC.NSObject {
    public static let schemes: Swift.Set<Swift.String>
    public enum Action : Swift.String {
      case close
      case customEvent
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public enum Error : Swift.Error, Swift.Hashable {
      case invalidCustomEvent(Foundation.URL)
      case invalidAction(Foundation.URL)
      case noBrazeInstance(Foundation.URL)
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: BrazeKit.Braze.WebViewBridge.SchemeHandler.Error, b: BrazeKit.Braze.WebViewBridge.SchemeHandler.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(channel: BrazeKit.Braze.Channel? = nil, logError: @escaping (BrazeKit.Braze.WebViewBridge.SchemeHandler.Error) -> Swift.Void, closeMessage: @escaping () -> Swift.Void, queryHandler: BrazeKit.Braze.WebViewBridge.QueryHandler, braze: BrazeKit.Braze?)
    final public func action(url: Foundation.URL) -> BrazeKit.Braze.WebViewBridge.SchemeHandler.Action?
    final public func process(action: BrazeKit.Braze.WebViewBridge.SchemeHandler.Action, url: Foundation.URL)
    @objc deinit
  }
}
extension BrazeKit.Braze.WebViewBridge.ScriptMessageHandler {
  @available(swift, obsoleted: 0.0.1)
  @objc @_Concurrency.MainActor @preconcurrency convenience dynamic public init(logClick: @escaping (Swift.String?) -> Swift.Void, logError: @escaping (Foundation.NSError) -> Swift.Void, closeMessage: @escaping () -> Swift.Void, braze: BrazeKit.Braze?)
  @available(swift, obsoleted: 0.0.1)
  @objc @_Concurrency.MainActor @preconcurrency convenience dynamic public init(logClick: @escaping (Swift.String?) -> Swift.Void, logError: @escaping (Foundation.NSError) -> Swift.Void, closeMessage: @escaping () -> Swift.Void, setBannerHeight: @escaping (Swift.Double) -> Swift.Void, braze: BrazeKit.Braze?)
}
extension BrazeKit.Braze.WebViewBridge {
  @objc(BRZWebViewBridgeScriptMessageHandler) @_Concurrency.MainActor @preconcurrency final public class ScriptMessageHandler : ObjectiveC.NSObject, WebKit.WKScriptMessageHandler {
    public enum Error : Swift.Error, Swift.Hashable, Swift.Sendable {
      case invalidPayload(Swift.String?)
      case noBrazeInstance(action: Swift.String, args: Swift.String)
      case invalidArg(action: Swift.String?, index: Swift.Int, arg: Swift.String, type: Swift.String)
      case noBridgeWebView
      case jsError(Swift.String)
      case deprecation(message: Swift.String)
      case unknown(BrazeKit.Braze.ErrorString)
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: BrazeKit.Braze.WebViewBridge.ScriptMessageHandler.Error, b: BrazeKit.Braze.WebViewBridge.ScriptMessageHandler.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    @_Concurrency.MainActor @preconcurrency public init(channel: BrazeKit.Braze.Channel? = nil, logClick: @escaping (Swift.String?) -> Swift.Void, logError: @escaping (BrazeKit.Braze.WebViewBridge.ScriptMessageHandler.Error) -> Swift.Void, closeMessage: @escaping () -> Swift.Void, setBannerHeight: @escaping (Swift.Double) -> Swift.Void = { _ in }, braze: BrazeKit.Braze?)
    @_Concurrency.MainActor @preconcurrency convenience public init(braze: BrazeKit.Braze?)
    @_Concurrency.MainActor @preconcurrency @objc final public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
    @_Concurrency.MainActor @preconcurrency final public func callAsyncJavaScript(_ functionBody: Swift.String, arguments: [Swift.String : Any] = [:], in webView: WebKit.WKWebView, completionHandler: (@_Concurrency.MainActor (Swift.Result<Any, BrazeKit.Braze.WebViewBridge.ScriptMessageHandler.Error>) -> Swift.Void)? = nil)
    @objc @_Concurrency.MainActor @preconcurrency public static let name: Swift.String
    @objc @_Concurrency.MainActor @preconcurrency public static let script: WebKit.WKUserScript
    @objc deinit
  }
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZWebViewController) @_Concurrency.MainActor @preconcurrency final public class WebViewController : UIKit.UIViewController, WebKit.WKNavigationDelegate, WebKit.WKUIDelegate {
    @objc @_Concurrency.MainActor @preconcurrency final public var url: Foundation.URL? {
      @objc get
      @objc set
    }
    @objc @_Concurrency.MainActor @preconcurrency final public var animateDismissal: Swift.Bool
    @objc @_Concurrency.MainActor @preconcurrency final public var systemOpenURL: ((Foundation.URL) -> Swift.Void)?
    @objc @_Concurrency.MainActor @preconcurrency final public var openNewWindowLinksInBrowser: Swift.Bool
    @_Concurrency.MainActor @preconcurrency @objc override final public func viewDidLoad()
    @_Concurrency.MainActor @preconcurrency @objc override final public func viewDidAppear(_ animated: Swift.Bool)
    @_Concurrency.MainActor @preconcurrency @objc final public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
    @_Concurrency.MainActor @preconcurrency @objc final public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
    @_Concurrency.MainActor @preconcurrency @objc final public func webView(_ webView: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: any Swift.Error)
    @_Concurrency.MainActor @preconcurrency @objc final public func webView(_ webView: WebKit.WKWebView, createWebViewWith configuration: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
    @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
    @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
    @objc deinit
  }
}
extension BrazeKit._COMPAT_ABKRequestProcessingPolicy : Swift.Equatable {}
extension BrazeKit._COMPAT_ABKRequestProcessingPolicy : Swift.Hashable {}
extension BrazeKit._COMPAT_ABKRequestProcessingPolicy : Swift.RawRepresentable {}
extension BrazeKit._COMPAT_ABKSDKFlavor : Swift.Equatable {}
extension BrazeKit._COMPAT_ABKSDKFlavor : Swift.Hashable {}
extension BrazeKit._COMPAT_ABKSDKFlavor : Swift.RawRepresentable {}
extension BrazeKit._COMPAT_ABKSdkMetadata : Swift.Equatable {}
extension BrazeKit._COMPAT_ABKSdkMetadata : Swift.Hashable {}
extension BrazeKit._COMPAT_ABKSdkMetadata : Swift.RawRepresentable {}
extension BrazeKit.Braze._OBJC_PushEnqueueBehavior : Swift.Equatable {}
extension BrazeKit.Braze._OBJC_PushEnqueueBehavior : Swift.Hashable {}
extension BrazeKit.Braze._OBJC_PushEnqueueBehavior : Swift.RawRepresentable {}
extension BrazeKit.Braze.PushEnqueueBehavior : Swift.Equatable {}
extension BrazeKit.Braze.PushEnqueueBehavior : Swift.Hashable {}
extension BrazeKit._OBJC_TriggerEvent : Swift.Equatable {}
extension BrazeKit._OBJC_TriggerEvent : Swift.Hashable {}
extension BrazeKit._OBJC_TriggerEvent : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessage.SlideFrom : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessage.TextAlignment : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessage.Orientation : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BrazeInAppMessageDismissalReason : Swift.Equatable {}
extension BrazeKit._OBJC_BrazeInAppMessageDismissalReason : Swift.Hashable {}
extension BrazeKit._OBJC_BrazeInAppMessageDismissalReason : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessage.DismissalReason : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessage.DismissalReason : Swift.Hashable {}
extension BrazeKit._OBJC_BRZChannel : Swift.Equatable {}
extension BrazeKit._OBJC_BRZChannel : Swift.Hashable {}
extension BrazeKit._OBJC_BRZChannel : Swift.RawRepresentable {}
extension BrazeKit.Braze.Channel : Swift.Equatable {}
extension BrazeKit.Braze.Channel : Swift.Hashable {}
extension BrazeKit.Braze.Channel : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BRZRequestPolicy : Swift.Equatable {}
extension BrazeKit._OBJC_BRZRequestPolicy : Swift.Hashable {}
extension BrazeKit._OBJC_BRZRequestPolicy : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BRZSDKFlavor : Swift.Equatable {}
extension BrazeKit._OBJC_BRZSDKFlavor : Swift.Hashable {}
extension BrazeKit._OBJC_BRZSDKFlavor : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Api.RequestPolicy : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Api.RequestPolicy : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Api.RequestPolicy : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Api.SDKFlavor : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Api.SDKFlavor : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Api.SDKFlavor : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Api.SDKMetadata : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Api.SDKMetadata : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Api.SDKMetadata : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.DeviceProperty : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.DeviceProperty : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.DeviceProperty : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Logger.Level : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Logger.Level : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Logger.Level : Swift.RawRepresentable {}
extension BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType : Swift.Equatable {}
extension BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType : Swift.Hashable {}
extension BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType : Swift.RawRepresentable {}
extension BrazeKit.Braze.ContentCardRaw.CardType : Swift.Equatable {}
extension BrazeKit.Braze.ContentCardRaw.CardType : Swift.Hashable {}
extension BrazeKit.Braze.ContentCardRaw.CardType : Swift.RawRepresentable {}
extension BrazeKit._objc_BRZInAppMessageUserIDMatchBehavior : Swift.Equatable {}
extension BrazeKit._objc_BRZInAppMessageUserIDMatchBehavior : Swift.Hashable {}
extension BrazeKit._objc_BRZInAppMessageUserIDMatchBehavior : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageType : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageType : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageType : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.ClickAction : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.ClickAction : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.ClickAction : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageClose : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageClose : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageClose : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.Orientation : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.Orientation : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.Orientation : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.TextAlignment : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.TextAlignment : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.TextAlignment : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.ImageStyle : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.ImageStyle : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.ImageStyle : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.SlideFrom : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.SlideFrom : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.SlideFrom : Swift.RawRepresentable {}
extension BrazeKit.Braze.Notifications.Payload._OBJC_PayloadType : Swift.Equatable {}
extension BrazeKit.Braze.Notifications.Payload._OBJC_PayloadType : Swift.Hashable {}
extension BrazeKit.Braze.Notifications.Payload._OBJC_PayloadType : Swift.RawRepresentable {}
extension BrazeKit.Braze.Notifications.Payload.PayloadType : Swift.Equatable {}
extension BrazeKit.Braze.Notifications.Payload.PayloadType : Swift.Hashable {}
extension BrazeKit.Braze.Notifications.Payload.PayloadType : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BrazeSessionState : Swift.Equatable {}
extension BrazeKit._OBJC_BrazeSessionState : Swift.Hashable {}
extension BrazeKit._OBJC_BrazeSessionState : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BRZUserSubscriptionState : Swift.Equatable {}
extension BrazeKit._OBJC_BRZUserSubscriptionState : Swift.Hashable {}
extension BrazeKit._OBJC_BRZUserSubscriptionState : Swift.RawRepresentable {}
extension BrazeKit.Braze.User.Gender : Swift.Equatable {}
extension BrazeKit.Braze.User.Gender : Swift.Hashable {}
extension BrazeKit.Braze.User.Gender : Swift.RawRepresentable {}
extension BrazeKit.Braze.User.SubscriptionGroupStatus : Swift.Equatable {}
extension BrazeKit.Braze.User.SubscriptionGroupStatus : Swift.Hashable {}
extension BrazeKit.Braze.User.SubscriptionGroupStatus : Swift.RawRepresentable {}
extension BrazeKit.Braze.User.SubscriptionState : Swift.Equatable {}
extension BrazeKit.Braze.User.SubscriptionState : Swift.Hashable {}
extension BrazeKit.Braze.User.SubscriptionState : Swift.RawRepresentable {}
extension BrazeKit.Braze.WebViewBridge.SchemeHandler.Action : Swift.Equatable {}
extension BrazeKit.Braze.WebViewBridge.SchemeHandler.Action : Swift.Hashable {}
extension BrazeKit.Braze.WebViewBridge.SchemeHandler.Action : Swift.RawRepresentable {}
extension BrazeKit.Braze.WebViewBridge.ScriptMessageHandler : Swift.Sendable {}
